\documentstyle{article}
\title{{\sc mff.sty}: Computer Modern Typefaces\\
as the Multiple Master Fonts\\[0.5\baselineskip]
\Large Version 1.21}

\author{
\begin{minipage}{0.4\textwidth}
\begin{center} A.S.Berdnikov\\{\tt berd{\sl @}ianin.spb.su} \end{center}
\end{minipage}
\hfill
\begin{minipage}{0.4\textwidth}
\begin{center} S.B.Turtia\\{\tt turtia{\sl @}ianin.spb.su} \end{center}
\end{minipage}
}

\date{}

\def\PiC{P\kern-.12em\lower.5ex\hbox{I}\kern-.075emC\spacefactor1000 }
\font\manual=logo10 at 12pt
\def\MF{{\manual META}\-{\manual FONT}\spacefactor1000 }
\def\AW{Addison\kern.1em-\penalty 0pt \hskip 0pt Wesley}
\def\CandT{{\sl Computers \& Typesetting}}
\def\TUB{{\sl TUGboat\/}}

\font\cmcmss=cmss12 scaled 1000
\font\cmcmbx=cmbx12 scaled 1000
\font\cmcmtt=cmtt12 scaled 1000
\font\cmcmsl=cmsl12 scaled 1000
\font\cmfunny=cmff10 scaled 1200
\font\cmquote=cmssq8 scaled 1200
\font\cmdunh=cmdunh10 scaled 1200
\font\cmcmr=cmr12 scaled 1000

\font\cmq=cmssq8 scaled 800
\font\cmd=cmdunh10 scaled 800
\font\csl=cmsl10 scaled 800

\newcommand{\bs}{\char92}   % char \

\makeatletter
\def\hackersmile{\@ifnextchar[{\@hackersmile}{\@hackersmile[10]}}
\def\@hackersmile[#1]{\hbox{%
   \unitlength=1pt\relax
   \unitlength=#1\unitlength
   \divide\unitlength by 10\relax
   \thicklines
   \raise -3\unitlength \hbox{%
   \begin{picture}(12,12)(-6,-6)
   \put(0,0){\circle{10}}
   \put(-2,1.75){\circle*{1}}
   \put(2,1.75){\circle*{1}}
   \thicklines
   \put(-2.75,3){\line(1,0){1.5}}
   \put(2.75,3){\line(-1,0){1.5}}
   \put(0,-1){\line(0,1){3}}
   \put(-2.5,-2.5){\line(1,0){5}}
   \put(-2.5,-2.5){\line(0,1){1}}
   \put(2.5,-2.5){\line(0,1){1}}
   \end{picture}%
}}}
\makeatother

\begin{document}

\maketitle

\begin{flushright}
\begin{minipage}{0.55\textwidth}
\small
We would like to express our warmest thanks
to Dr.\ A.Compagner from the Delft University of Technology
who spent a lot of his time and efforts
trying to transform two naive students from Russia
into serious scientists.
\end{minipage}
\end{flushright}

\bigskip

\begin{abstract}
The style file {\sc mff.sty} simulates the effect of
{\sl Multiple Master Fonts} created by Adobe using
the Computer Modern typefaces as a template.
It enables to vary continuously in a wide range
the shape of \TeX{} fonts and create the unique font
which suites the User's demands.
Although originally {\sc mff.sty} was created for internal
purposes to investigate the possibilities  hidden inside
the \MF{} source code for Computer Modern typefaces,
it might be useful for professional applications too.
The style file works correctly with
\LaTeX{} 2$_{\hbox{\normalsize$\varepsilon$}}$
as well as with \LaTeX{} $2.09$.
\end{abstract}

\section{Introduction}

The {\sl Multiple Master Font} format for PostScript
fonts was suggested some time ago
by the well-known company {\sl Adobe Inc}.
It enables to vary continuously the
font characteristics (say, {\em weight} (``boldness'')
from light to black, {\em width} from condensed to expanded,
etc.) and create the unique font which suites
the particular User's demands.
Like many other ``new inventions''
in computer assisted typography, the roots of this
idea can be found inside \TeX{}\footnote{For example,
{\sl Microsoft Word} 6.0 was announced as the {\em first}
program which enables to mark some place in the text by
a special marker and then to refer to its position
in a form: ``see page \dots'' \hackersmile.} --- namely, in \MF{}
as the language for font description, and in Computer
Modern font family created by D.Knuth in 1977--1985.

The \MF{} source code was created, and the {\sl Computer Modern}
font parameters were selected using the advises of such
professional font designers as Hermann Zapf,
Matthew Carter, Charles Bigelow and others
(see \cite{CM} for the {\em full} list of contributors).
The \MF{} code for {\sl Computer Modern} typefaces
has the following essential features:
\begin{itemize}
\item
the parameter files are separated from the main source code
so that the font parameters can be variated easily;
\item
the role of the font parameters, the details of the \MF{} source code,
etc., are documented in \cite{CM} in deep details;
\item
the font variations (provided that the fonts and all
changed {\tt .mf} files have the names \underline{\bf different}
from that for the original CM fonts)
are encouraged by the author.
\end{itemize}
The {\sl Computer Modern} fonts are parametrized using
sixty two \hbox{(!!!)} parameters most of which are independent.
It can be seen easily that such big amount of free parameters
exceeds the flexibility of {\em any} multiple master font
which is created up to now or even {\em will be} created
by somebody in future.

The continuous parametrization of the canonical Computer Modern
typefaces created by John Sauter and Karl Berry
({\sc sauter} fonts \cite{SAUTER}), and, on a different basis,
by J\"org Knappen and Norbert Schwarz for
{\sl European Computer Modern} typefaces \cite{DC},
enables to vary continuously the font size in a wide range
without loosing the high quality of the output.
As a result it is easy to manipulate with
{\sl Computer Modern} typefaces like the Adobe multiple master fonts,
and to produce an enomorous amount of {\bf freeware}
fonts of professional quality.

The style file {\sc mff.sty} described here performs this work.
It follows the ideas implimented in the package MF\PiC{}\footnote{%
Like MF\PiC, the first pass of \LaTeX{}
creates the {\tt .mf} file,
then the {\tt .mf} file is processed by \MF,
and at the second pass of \LaTeX{} the new
font is used to make the output.}
and enables to specify the new fonts inside \LaTeX{} document
without dealing with the details of \MF{} programming and
manual specification of each of 62 parameters used in
{\sl Computer Modern} source files.
The User can variate the font shape continuously between
CMR, CMBX, CMSL, CMSS, CMTT and CMFF font families,
specify the {\em weight}, {\em width}, {\em height}
and {\em contrast} of the output font independently,
and in addition he/she can play the character
characteristics so that the output does not
look like the canonical {\sl Computer Modern}
typefaces at all.

\section{Main Command: define a font\label{GENER}}

The generation of the {\tt .mf} header file and the activation
of the new font is performed by the command
{\tt\bs{}MFFgener} which has the format:
\begin{itemize}
\item[] \tt \bs{}MFFgener[{\em fntscaled}]\{{\em{\tt\bs}fntcmd}\}\{{\em filename}\}\{{\em fntsize}\}
\end{itemize}
The command {\em{\tt\bs}fntcmd} will switch inside the document
to the desired font like it is done by the \LaTeX{} commands
\verb?\bf?, \verb?\sl?, \verb?\sf?, etc.\footnote{The difference is that
the size of this font is not influenced by the commands like
{\tt\bs{}large} or {\tt\bs{}small} --- it is fixed and is
determined totally by the parameters {\em fntscaled} and {\em fntsize}.}
The file {\em filename{\tt.mf}} will contain the \MF{} source
code of the new font\footnote{To minimize the attempts to create the
fonts with the names already used in Computer Modern family, etc.,
the prefix {\em xx} is added before the file name automatically.
See section~\ref{MORE} for more details.}.
The value {\em fntsize} specifies the design size
of the new font (it defines the size of a new font and
is used by {\sc mff.sty} to calculate the font parameters
as the functions of this reference value ---
see sections \ref{MIXTURE} and \ref{CORRECT} for more details).
The optional parameter {\em fntscaled} specifies
the additional scaling of this font in \LaTeX{} document.
Examples:
\begin{itemize}
\item[]\verb?\MFFgener{\zfnt}{zmz30}{30pt}?\\
       \verb?\MFFgener[scaled 2000]{\zfnt}{zmz15}{15pt}?\\
       \verb?\MFFgener[at 30pt]{\zfnt}{zmz20}{20pt}?
\end{itemize}

The {\tt .mf} file created by {\sc mff.sty}
contains only the list of 62 font
parameters which determine the character shapes.
It also contains the command that loads the
driver file ({\tt roman.mf}, {\tt csc.mf}, etc.),
and the driver file assemblers all the necessary \MF{} source code.
It is assumed that the driver files for the fonts described
in section~\ref{CLASS} together with all necessary
{\tt .mf} files are already installed on your computer.

When the file {\em filename{\tt.mf}} is created,
it is necessary to process it by \MF{} to get the metric
file {\em filename{\tt.tfm}} and the bitmap file
{\em filename{\tt.pk}}. The second pass of \LaTeX{} will use the metric
information to format the document properly, and the {\sl DVI}-drivers
will use the bitmap data to make the output.
The proper configuration of \TeX-compiler and {\sl DVI}-drivers
so that they can find these files is the User's task
(please consult your local \TeX-expert how to configure
it\footnote{Some advises how to configure the programs
if you use {\sl MS DOS}/{\sf em\TeX} are in section~\ref{CONFIG}.}).

If \LaTeX{} can find the file {\em filename}{\tt .tfm}, it assigns
the font {\em filename} to the command {\em{\tt\bs}fntcmd} which
can be used later in the document to switch to the desired font.
If \LaTeX{} cannot find the {\tt .tfm} file, the warning message
\begin{itemize}
\item[] {\tt No file {\em filename}.tfm -- dummy font will be used}
\end{itemize}
is displayed which means that the text typed by this new font
will disappear from the {\sl DVI}-file ({\tt dummy} font is the
artificial font which contains no characters).

The file {\em filename{\tt.mf}} which contains the \MF{} data
necessary to make the font is created after {\em each} pass
of \LaTeX{} and the warning message
\begin{itemize}
\item[] {\tt Do not forget to process {\em filename}.mf
             and reprocess this file}
\end{itemize}
is displayed even if the new {\tt .mf} file is identical to the previous
one. It is the User's responcibility to guarantee that the {\sc mff.sty}
commands are the same as during the previous pass of \LaTeX{} and that
the {\tt .tfm} and {\tt .pk} files are produced from the correct version
of {\tt .mf} file.

\section{Mixture of independent fonts\label{MIXTURE}}

The {\sl Computer Modern} font sequences
\begin{itemize}
\item[]\begin{flushleft}
{\cmcmr roman},\quad {\cmcmbx bold},\quad
{\cmcmsl slanted},\quad {\cmcmss sans serif},\quad
{\cmcmtt typewriter},\quad {\cmfunny funny},\quad
{\cmdunh dunhill},\quad {\cmquote quotation}\end{flushleft}
\end{itemize}
share just the same \MF{} source code but with different values for
font parameters. Since each font exists at different sizes, it is
possible to construct for each sequence and for each parameter
a continuous approximation which is the function of the font size.
Such approximations, for example, enable to generate fonts with the
font sizes different from that created by D.E.Knuth.

At least two {\em ready-to-use} font approximations are available from
CTAN. One is the {\sc sauter} font package created by
John Sauter and Karl Berry \cite{SAUTER}, and the other is realized
in {\sc dc} and {\sc tc} fonts created by J\"org Knappen and Norbert
Schwarz \cite{DC}. Special {\sc mff.sty} comands control
the approximation scheme:
\begin{itemize}
\item[] {\tt \bs{}MFFsauter} --- {\sc sauter}-type approximation
        is used;\\
        {\tt \bs{}MFFdcfonts} --- {\sc DC font} approximation
        is used;
\end{itemize}
where the default mode is {\tt\bs{}MFFsauter}.

The continuous approximation for CMR parameters enables to create
the \MF{} header file for CMR font with an arbitrary font size.
Similar approximations and, as a result, the font headers with
an arbitrary font size, can be constructed for CMBX, CMTT, CMSS, etc.
The main hypothesis used below is the following:
if some font headers result to correct fonts when processed by \MF{},
the font header contructed from the {\em weighted sum} of the font
parameters extracted from these font headers gives
the correct font also\footnote{The internal relations between
font parameters described in \cite{CM} are conserved for the weighted
sum of font parameters.}.
Although it is not necessarily true, the experiments
with {\sl Computer Modern} typefaces show that if the header files
corresponding to different {\sl Computer Modern} fonts
{\em with the same font size} are selected, this assumption is fulfilled
with great probability.

The fonts CMR, CMBX, CMTT, CMSS, etc., have quite different
character styles although they use just the same \MF{} driver file
{\tt roman.mf}.
The CMTT fonts have nearly rectangular serifs,
nearly no contrast between thin and thick lines,
and different ratio width/height as compared with CMR.
The CMSS fonts has no serifs at all, they also
have no contrast, the thickness of their lines is greater
than that for CMTT.
Other fonts have their own specific
features, but inspite of this fact they can be ``added''
together --- at least mathematically as the 62-dimensional
vectors of font parameters.
The resulting font is no longer CMR, CMBX, CMTT, etc.,
but something intermediate with a unique shape.

Taking into account the {\sf New Font Selection Scheme} used by
\LaTeX~2$_{\hbox{\normalsize$\varepsilon$}}$,
it is preferable to decompose
the CMBX font sequence into {\em two} sequences --- one
for ``boldness'' ({\em weight}) and one for ``extension''
({\em width}) characteristics.
The {\sc mff.sty} uses the special fonts
$\overline{\hbox{CMB}}$\footnote{It is not the same as
{\tt cmb10} created by D.E.Knuth --- the font parameters
are different.}  (bold as CMBX and wide as
CMR) and $\overline{\hbox{CMX}}$ (wide as CMBX and bold as CMR)
which are derived from CMBX.

The mixture of fonts is performed by the command
\begin{itemize}
\item[] {\tt \bs{}MFFmixture\{$\alpha_1$\}\{$\alpha_2$\}%
            \{$\alpha_3$\}\{$\alpha_4$\}\{$\alpha_5$\}\{$\alpha_6$\}}
\end{itemize}
where $\alpha_1$, $\alpha_2$, $\alpha_3$, $\alpha_4$,
$\alpha_5$,  $\alpha_6$ specify
the weight factors:
$\alpha_1$ corresponds to $\overline{\hbox{CMB}}$,
$\alpha_2$ corresponds to $\overline{\hbox{CMX}}$,
$\alpha_3$ corresponds to CMSS (sans serif fonts),
$\alpha_4$ corresponds to CMTT (typewriter fonts),
$\alpha_5$ corresponds to CMFIB (``Fibonacci'' fonts),
$\alpha_6$ corresponds to CMFF (funny fonts)\footnote{%
The fonts {\csl slanted}, {\cmq quotation} and {\cmd dunhill}

are not included in this list because they can be produced
from CMR easily using the scaling commands described
in section~\ref{CORRECT}.}.

If some parameter has the value $p_{cmr}$ for CMR font,
the value $p_{cmb}$ for $\overline{\hbox{CMB}}$ font
(with the same font size!), the value $p_{sf}$ for CMSS font, etc.,
the {\em mixture} value $p_*$ for this parameter is calculated as
\begin{eqnarray}
p_* &=& \alpha_0 p_{cmr}
    + \alpha_1 \left(p_{cmb}-p_{cmr}\right)
    + \alpha_2 \left(p_{cmx}-p_{cmr}\right)
    + \alpha_3 \left(p_{sf}-p_{cmr}\right)
\cr &&\quad\quad
    + \alpha_4 \left(p_{tt}-p_{cmr}\right)
    + \alpha_5 \left(p_{fib}-p_{cmr}\right)
    + \alpha_6 \left(p_{funny}-p_{cmr}\right)
\label{Eq1}
\end{eqnarray}
The value $\alpha_0$ is set to 1.0 by the command {\tt \bs{}MFFmixture},
but the User can assign an arbitrary value to it using the
commands {\tt\bs{}setMFF[$\alpha_0$]\{cmr\}} and
{\tt\bs{}mixMFF[$\alpha_0$]\{cmr\}} which are decribed below.

This procedure enables, for example, to make the font ``less bold''
than CMR or ``more bold'' and ``more extended'' than CMBX
using the weight factors which are less than 0 or greater than 1,
and to create the ``mutant'' combinations of nearly incompatible
font families\footnote{Caution: playing this game
it is very easy to get the {\tt .mf} file which cannot
be passed through \MF{} without errors if you do not
understand clearly what are you doing.}.

The command
       {\tt \bs{}MFFmixture\{$\alpha_{1}$\}\{$\alpha_{2}$\}%
            \{$\alpha_{3}$\}\{$\alpha_{4}$\}\{$\alpha_{5}$\}%
            \{$\alpha_{6}$\}}
is equivalent to the following sequence of commands:
\begin{itemize}
\item[]{\tt \bs{}clearMFF\ \ \ \ \ \
  \% synonim for \bs{}MFFmixture\{0\}\{0\}\{0\}\{0\}\{0\}\{0\}}\\
       {\tt \bs{}mixMFF[$\alpha_{1}$]\{bold\}} \\
       {\tt \bs{}mixMFF[$\alpha_{2}$]\{x\}} \\
       {\tt \bs{}mixMFF[$\alpha_{3}$]\{sf\}} \\
       {\tt \bs{}mixMFF[$\alpha_{4}$]\{tt\}} \\
       {\tt \bs{}mixMFF[$\alpha_{5}$]\{fib\}} \\
       {\tt \bs{}mixMFF[$\alpha_{6}$]\{funny\}}
\end{itemize}
These commands are better recognized due to their mnemonic form,
they can be specified in an arbitrary order, the  commands with
zero $\alpha$'s can be skipped since the zero weight factors are
already assigned by {\tt\bs{}clearMFF}.
If several commands with the same font name are encountered,
the last specification is active. The default value for the
optional parameter $\alpha$ is {\tt 1.0}.

The mixture between CMR and a {\em single} font can be
specified by a single mnemonic command selected from
\begin{center}\begin{tabular}{l@{\qquad}l@{\qquad}l}
{\tt \bs{}setMFF[$\alpha_{1}$]\{bold\}} &
{\tt \bs{}setMFF[$\alpha_{3}$]\{sf\}} &
{\tt \bs{}setMFF[$\alpha_{5}$]\{fib\}} \\
{\tt \bs{}setMFF[$\alpha_{2}$]\{x\}} &
{\tt \bs{}setMFF[$\alpha_{4}$]\{tt\}} &
{\tt \bs{}setMFF[$\alpha_{6}$]\{funny\}}
\end{tabular}\end{center}
which is equivalent to {\tt \bs{}MFFmixture} where only
one weight factor has non-zero value. If the optional parameter $\alpha$
is skipped, the default value {\tt 1.0} is used. It means that
the ``pure'' font family can be specified by the commands
\begin{center}\begin{tabular}{l@{\qquad}l@{\qquad}l}
{\tt \bs{}setMFF\{bold\}} &
{\tt \bs{}setMFF\{sf\}} &
{\tt \bs{}setMFF\{fib\}} \\
{\tt \bs{}setMFF\{x\}} &
{\tt \bs{}setMFF\{tt\}} &
{\tt \bs{}setMFF\{funny\}}
\end{tabular}\end{center}

Although \LaTeX{} 2$_{\hbox{\normalsize$\varepsilon$}}$/NFSS
considers the {\em weight} and the {\em width} as two
independent font characteristics, the movement in the direction
``bold + extended'' (i.e., to CMBX font family) usually gives
more pleasant results.
To perform this operation it is necessary to assign the equal weights
to $\alpha_{cmb}$ and $\alpha_{cmx}$ which can be done
by the mnemonic commands
\begin{itemize}
\item[]{\tt \bs{}mixMFF[$\alpha_{bx}$]\{bx\}}
      \qquad and \qquad
       {\tt \bs{}setMFF[$\alpha_{bx}$]\{bx\}}
\end{itemize}
The commands
\begin{itemize}
\item[]{\tt \bs{}mixMFF[$\alpha_{cmr}$]\{cmr\}}
      \qquad and \qquad
       {\tt \bs{}setMFF[$\alpha_{cmr}$]\{cmr\}}
\end{itemize}
play a special role: they enable to assign the value
$\alpha_0=\alpha_{cmr}$ in the equation~(\ref{Eq1})
(usually $\alpha_0$ is set to 1.0 by the command
{\tt\bs{}MFFmixture} --- for the evident reasons).

%\section*{Some notes about the font sequences
%         with continuously variated font size}
%
%Suppose that there is a continuous approximation
%for {\sl Computer Modern Roman} (CMR) which enables
%to calculate the \MF{} font parameters for an {\em arbitrtary}
%design size even with weak \TeX{} arithmetical capabilities.
%The desired font size is specified as the input parameter,
%all the internal calculations of the font parameters are performed
%by \TeX{}, and at the output there is the \MF{} {\em ready-to-run}
%font header file for a new font. When this new font header file
%is processed by \MF{}, it can be used in \TeX{} documents like
%other generic \TeX{} fonts.
%
%It is interesting to compare the possibilities of this simplest
%form of pa\-ra\-me\-tri\-za\-ti\-on
%of CMR-fonts and the {\sc PostScript} vector fonts.
%The nearly-proportional changing of the font dimensions
%with respect to magnification parameter is the analog of the
%linear scaling of the {\sc PostScript} fonts.
%The non-linear relationship of the inter-character spacing from
%the font size imitates the {\em tracking} mechanism implemented
%in {\sc PostScript} fonts (which is not taken into account in most
%cases by text processors). The fact that the ratio height/width is a
%non-constant (and non-linear) function of the font size is a
%serious advantage of these pseudo-CMR fonts in comparison with
%the linearly scaled {\sc Postscript} fonts since it enables to make
%the font proportions more suitable for a human eye
%(it is well known that for good eye recognision small letters
%are to be more expanded and have greater inter-character spacing).
%
%There are at least {\em two} ready-to-use font approximations
%available from CTAN. The first one is the \MF{} {\sc sauter}
%font package created by John Sauter and Karl Berry. It uses
%the continuous functions composed from constant, linear and quadratic
%pieces which are constructed so that for {\em canonical} font sizes they
%produce nearly just the same {\tt *.mf} files as the ones used
%by the original {\sl Computer Modern} typefaces. Although the latest
%version of {\sc sauter} is dated 1992, and in 1995 the parameters
%of {\sl Computer Modern} fonts were again slightly changed,
%it seems still to be the reliable source of the fonts with
%intermediate design sizes.
%
%The other approximation is realized in {\sc dc} and {\sc tc}
%fonts by by J\"org Knappen and Norbert Schwarz \cite{DC}.
%It is based on cubic splines --- Lagrange cubic splines or
%canonical cubic splines --- using the parameters of
%{\sl Computer Modern} typefaces as the base points.
%Although generally piecewise-cubic functions produce
%good quality approximations, it is not so with the data extracted
%from {\sl Computer Modern} \MF{} files. The plots of its parameters
%with respect to the design size are ``noisy'' functions with some
%abrupt jumps since these parameters were selected
%manually to optimize the font shape, not the mathematical plots.
%As a result the cubic smooth approximations obey parasilic local
%minima and maxima and do not work far outside the range of
%design sizes used as the base data points. The {\sc dc} and {\sc tc}
%fonts with intermediate font sizes are visually good even with
%this ``mathematical'' defects but it was more advantageous
%to impliment piecewise-linear approximation instead of
%piesewise-cubic one.
%
%The first version of {\sc mff.sty} was based on piecewise-linear and
%piecewise-cubic (Lagrange splines) functions using {\sl Computer Modern}
%typefaces as the reference data. To eliminate the parasitic local
%minima and maxima some data points were slightly changed, and new
%data points were added to guarantee a good behavour of the approximating
%expressions outside the range {\tt 5pt} -- {\tt 17.28pt}. The current
%version of {\sc mff.sty} is based on {\sc sauter}-type approximation
%with some modifications (especially for {\tt cmff} and {\tt cmfib} fonts)
%and on the piecewise-linear approximations based on {\sc dc} data.
%The variated {\sl Computer Modern} data used in the previous versions
%became obsolete and is discarded now since it is not a good idea
%to modify voluntary the original {\sc Computer Modern} parameters.

\section{Modifications of font parameters\label{CORRECT}}

You can use the weighted mixture of font ingredients using the commands
{\tt\bs{}setMFF}, {\tt\bs{}mixMFF} and {\tt\bs{}MFFmixture} described
above, but you can also vary ``by hand'' the font parameters
which control the essential details of the character shape.
%The commands described in this section enable to do:
%\begin{itemize}
%\item scale the {\em width} of the character;
%\item scale the {\em height} of the character;
%\item scale the length of ascenders and descenders;
%\item scale the height of digits and the middle line for
%      mathematical symbols;
%\item scale the thickness of {\em thin strokes}
%      and {\em thick strokes};
%\item correct the {\em contrast} of the character;
%\item specify the tilt ratio $(\Delta x/\Delta y)$
%      for {\sl slanted} fonts;
%\item scale (or set to some value) some specific parameters
%      which are responcible for fine character tuning;
%\item specify the logical flags which control the ligatures,
%      character serifs, etc.
%\end{itemize}

\subsection{Variations of the height\label{HEIGHT}}

The following commands enable to vary the height of the vertical
elements of the characters:
\begin{description}
\item[\quad{\tt \bs{}MFFscaleHeight\{{\em factor}\}}] --- scale proportionally
     the height and the depth of the characters;
\item[\quad{\tt \bs{}MFFscaleAsc\{{\em factor}\}}] --- scale
     the height of the capital characters, brackets, digits, etc.,
     and the ascenders of the characters like `b', `h';
\item[\quad{\tt \bs{}MFFscaleDesc\{{\em factor}\}}] --- scale
     the depth of comma and the descenders of the characters
     like `Q', `y';
\item[\quad{\tt \bs{}MFFscaleMath\{{\em factor}\}}] --- scale
     the height of digits and the height of
     the horizontal bar (the middle line) for mathematical symbols
     like $=$, $+$, $-$.
\end{description}
If several height factors are specified, their effect is combined.
The curious font {\tt cmdunh10} can be reproduced {\em exactly}
by proper specification of all these factors.

Example:
\begin{eqnarray*}
&&\hbox{\tt \bs{}MFFscaleAsc\{1.5\}}\\
&&\hbox{\tt \bs{}MFFscaleDesc\{1.2\}}
\end{eqnarray*}

\subsection{Variations of the width\label{WIDTH}}

The {\em width} of CMR font can be variated by mixturing
with the $\overline{\hbox{CMX}}$ font. It increases the character width
and also performs some fine tuning of other font parameters.
Due to this reason the mixturing with
$\overline{\hbox{CMX}}$ can be advantageous to variate
the width of characters if you deal with CMR family.
From the other side, for CMTT fonts or CMSS fonts the
mixturing with $\overline{\hbox{CMX}}$ results also
to some variation of the character shapes which can be
an undesirable effect.

The User can specify the explicit width multiplication
which means that the font parameters which define the width
of the characters are multiplied by some factor:
\begin{itemize}
\item[]{\tt \bs{}MFFscaleWidth\{{\em factor}\}}
\end{itemize}
After this command the font parameters
\begin{itemize}
\item[]\begin{flushleft}
{\tt u\#}, {\tt serif\_fit\#}, {\tt cap\_serif\_fit\#},
{\tt jut\#}, {\tt cap\_jut\#}
\end{flushleft}\end{itemize}
are scaled proportionally to {\em factor}.
The values $\hbox{\em factor}>1.0$ correspond to expansion,
the values $0<\hbox{\em factor}<1.0$ --- to compression of the
characters. The command {\tt \bs{}MFFscaleWidth\{1.0\}}
restores the default width.

\subsection{Variations of the weight\label{WEIGHT}}

The {\em weight}, i.e., the ``boldness'' of the characters can be
controlled by muxturing with $\overline{\hbox{CMB}}$.
Similarly to {\em width} correction described in the previous section,
for such fonts as CMTT or CMSS it is accompanied
by some undesirable changes in the character shapes.

The following commands control explicitly
the {\em weight} and the {\em contrast} of the characters:
\begin{description}
\item[\quad{\tt \bs{}MFFscaleBoldLines\{{\em coef}$_1$\}}]
--- scale the thickness of {\em thick} strokes by {\em coef}$_1$;
\item[\quad{\tt \bs{}MFFscaleThinLines\{{\em coef}$_2$\}}]
--- scale the thickness of {\em thin} strokes by {\em coef}$_2$.
\end{description}
The coefficient {\em coef}$_1$ scales the values of the font parameters
\begin{itemize}
\item[]\begin{flushleft}
{\tt stem\#}, {\tt curve\#}, {\tt ess\#}, {\tt flare\#}, {\tt dot\_size\#},
{\tt cap\_stem\#}, {\tt cap\_curve\#}, {\tt cap\_ess\#},
{\tt bar\#}, {\tt slab\#}, {\tt cap\_bar\#}, {\tt cap\_band\#},
{\tt thin\_join\#}.
\end{flushleft}\end{itemize}
The coefficient {\em coef}$_2$ scales the values of font parameters
\begin{itemize}
\item[]\begin{flushleft}
{\tt hair\#}, {\tt vair\#}, {\tt cap\_hair\#},
{\tt rule\_thickness\#}, {\tt notch\_cut\#}, {\tt cap\_notch\_cut\#}.
\end{flushleft}\end{itemize}

Multiplication by {\em coef}$_1$ and {\em coef}$_2$ increases
the font contrast in $\hbox{\em coef}_1/\hbox{\em coef}_2$ times.
The contrast can be specified explicitly using the commands
\begin{itemize}
\item[]{\tt \bs{}MFFcontrast[{\em type}]}\qquad or \qquad
       {\tt \bs{}MFFcontrast\{{\em value}\}}
\end{itemize}
which defines the parameter {\em value} equal to the ratio
of the thickness of {\em thin strokes} to the thickness of
{\em thick strokes}. The commands work as:
\begin{eqnarray*}
&&\hbox{{\tt\bs{}MFFcontrast[s]} --- no correction of the contrast;}\\
&&\hbox{{\tt\bs{}MFFcontrast[n]} --- no contrast at all ({\em value}=1);}\\
&&\hbox{{\tt\bs{}MFFcontrast[d]} --- 50\% contrast ({\em value}=0.5);}\\
&&\hbox{{\tt\bs{}MFFcontrast\{{\em value}\}}
            --- the {\em value} is specified explitly.}
\end{eqnarray*}
If the correction of the contrast is active
(no command {\tt\bs{}MFFcontrast[s]}),
all thick element of lowercase characters are equal to {\tt stem\#},
all thick element of uppercase characters are equal to {\tt cap\_stem\#},
all thin elements have the thickness of {\tt stem\#} or {\tt cap\_stem\#}
multiplied by {\em value}, the values {\tt stem\#} and {\tt cap\_stem\#}
are multiplied by $\hbox{\em coef}_1$,
the value $\hbox{\em coef}_2$ is ignored.

\subsection{Miscellaneous variations\label{MISC}}

The following scaling factors can help to perform fine tuning
of the characters (see \cite{CM} for more details):
\begin{description}
\item[\quad{\tt \bs{}MFFscaleJoinLines\{{\em factor}\}}]
---  variable {\tt thin\_join\#} is multiplied by {\em factor}
     (this variable is responcible
     for fine connection between thin and thick lines in `h', `m', `n');
\item[\quad{\tt \bs{}MFFscaleNotchCut\{{\em factor}\}}] ---
     variables {\tt notch\_cut\#} and {\tt cap\_notch\_cut\#} are
     multiplied by {\em factor} (these variables
     are responcible for sharp corners in letters `A', `V', `w');
\item[\quad{\tt \bs{}MFFscaleDotSize\{{\em factor}\}}] ---
     variables {\tt dot\_size\#} and {\tt flare\#} are multiplied
     by {\em factor} (these variables
     are responcible for dots in `i', `:' and bulbs in `a', `c');
\item[\quad{\tt \bs{}MFFscaleSerifDish\{{\em factor}\}}] ---
     variable {\tt dish\#} is multiplied by {\em factor} (this
     variable defines the curved shape of the serif platform).
\end{description}

Since these parameters perform fine tuning of the character shape,
it can be desirable to assign the specific value to some of them
instead of scaling the default value.
This operation requires the ``expert level macros''
described in section~\ref{EXPERT}.
For example, to assign a very big number to the variables
{\tt notch\_cut\#} and {\tt cap\_notch\_cut\#}
which control the sharpness of the corners in letters `A', `V', `w',
etc.\footnote{This operation is necessary to produce high-quality
outlined characters using {\em font tricks} commands described
in section~\ref{TRICKS} (see \cite{Outline} for more
details).}, the following commands can be used:
\begin{itemize}
\item[]
    {\tt\bs{}MFFcatcode}\\
    {\tt \bs{}def\bs{}MFF@assign@notch\_cut\{\bs{}@tempdimb=16383pt\}}\\
    {\tt \bs{}def\bs{}MFF@assign@cap\_notch\_cut\{\bs{}@tempdimb=16383pt\}}\\
    {\tt\bs{}noMFFcatcode}
\end{itemize}
To return the rule of calculation for these parameters
to the default state, the commands
\begin{itemize}
\item[]
    {\tt\bs{}MFFcatcode}\\
    {\tt \bs{}def\bs{}MFF@assign@notch\_cut\{\}}\\
    {\tt \bs{}def\bs{}MFF@assign@cap\_notch\_cut\{\}}\\
    {\tt\bs{}noMFFcatcode}
\end{itemize}
should be used.

\subsection{Slanted characters\label{SLANT}}

The inclination of the characters is defined by the
variable {\tt slant\#} which is specified explicitly
by the commands:
\begin{itemize}
\item[]{\tt \bs{}MFFslant\{{\em parm}\}} --- set {\em slant} as a fraction;
\item[]{\tt \bs{}MFFslantD\{{\em parm}\}} --- set {\em slant} as an angle
     specified in degrees.
\end{itemize}
For example, {\em slant} typical for CMSL is specified
as {\tt \bs{}MFFslant\{1/6\}}, and {\em slant} typical for
CMSSI is specified as {\tt \bs{}MFFslantD\{12\}} which is
just the same as {\tt \bs{}MFFslant\{sind(12)/cosd(12)\}}.
The arguments of the commands {\tt\bs{}MFFslant} and {\tt\bs{}MFFslantD}
are interpreted as the text strings directly transferred to
{\tt .mf} files, not as the numerical values.


\subsection{Logical flags\label{FLAGS}}

The logical switches usually specified at the end of {\tt *.mf}
file can be controlled by the following commands
({\sl char}={\tt n} means {\em false}, {\sl char}={\tt y} means {\em true}):
\begin{description}
\item[\quad{\tt \bs{}MFFflagSquareDots\{{\sl char}\}}] --- set logical variable
    {\tt square\_dots} (should dots be square?);
\item[\quad{\tt \bs{}MFFflagHefty\{{\sl char}\}}] --- set logical variable
    {\tt hefty} (should we try hard not to be overweight?);
\item[\quad{\tt \bs{}MFFflagSerifs\{{\sl char}\}}] --- set logical variable
    {\tt serifs} (should bulbs and se\-rifs be attached?);
\item[\quad{\tt \bs{}MFFflagMonospace\{{\sl char}\}}] --- set logical variable
    {\tt monospace} (are all characters of the same width?);
\item[\quad{\tt \bs{}MFFflagVariantG\{{\sl char}\}}] --- set logical variable
    {\tt variant\_g} (should an italic-style g be used?);
\item[\quad{\tt \bs{}MFFflagLowAsterisk\{{\sl char}\}}] --- set logical variable
    {\tt low\_asterisk} (should the asterisk be centered at the axis?);
\item[\quad{\tt \bs{}MFFflagMathSpacing\{{\sl char}\}}] --- set logical variable
    {\tt math\_fitting} (should math-mode spacing be used?).
\end{description}
The level of ligature and kerning data is specified by the command:
\begin{description}
\item[\quad{\tt \bs{}MFFflagLigs\{{\em type}\}}] where {\em type} is
     {\tt 0}, {\tt 1}, {\tt 2}, {\tt s} or {\tt n} --- set ligature level:
     {\tt 0}, {\tt 1}, {\tt 2}  correspond to the value of the variable {\tt ligs},
     {\tt n} is equivalent to {\tt 0}, {\tt s} set ligature level like
     in CMR fonts (it is {\tt 1} if font design size is less than {\tt 6pt},
     and {\tt 2} otherwise).
\end{description}

\subsection{Expert level macros\label{EXPERT}}

It is possible to change manually each font variable
if the default value calculated by {\sc mff.sty} is
not satisfactory. To perform such operation it is necessary
to specify the macro with the name
\begin{itemize}
\item[] {\tt \bs{}MFF@assign@{\em varname}}
\end{itemize}
which redefine the value of the register \verb?\@tempdimb?.
On input the register \verb?\@tempdimb?
is equal to automatically calculated value for that parameter,
and the register \verb?\@tempdima? is equal to the font design size.
On output the register \verb?\@tempdimb? should contain
the new value for the font parameter.
When the macro {\tt\bs{}MFF@assign@{\em varname}} is executed,
the correction procedure described in section~\ref{CORR}
is performed.

For example, the following macro
\begin{itemize}
\item[] {\tt \bs{}def\bs{}MFF@assign@x\_height\{\bs{}@tempdimb=3\bs{}@tempdimb\}}
\end{itemize}
scales by 3 the font variable {\tt x\_height\#}, and the macro
\begin{itemize}
\item[] {\tt \bs{}def\bs{}MFF@assign@crisp\{\bs{}@tempdimb=0pt\}}
\end{itemize}
assigns zero value to the font variable {\tt crisp\#}.
To delete this user-specified transformation it is
necessary to use the explicit dummy definition
\begin{itemize}
\item[] {\tt \bs{}def\bs{}MFF@assign@x\_height\{\}}\\
        {\tt \bs{}def\bs{}MFF@assign@crisp\{\}}
\end{itemize}

The characters `{\tt \_}' and `{\tt @}' should have the status
{\em letters} to type such macro definition. The command
{\tt\bs{}MFFcatcode} assigns the status {\em letters} to
`{\tt \_}' and `{\tt @}', and the command {\tt\bs{}noMFFcatcode}
returns the previous status for these characters.
These commands work correctly even inside {\tt .sty} files where
the character `{\tt @}' have the status {\em letter} before \LaTeX{}
starts to process the style file, and should conserve this status
when \LaTeX{} finishes to process the style file.
Since the command {\tt\bs{}noMFFcatcode} returns {\em the previous}
status to `{\tt \_}' and `{\tt @}' (that is, the catcode which
they have during the last command {\tt\bs{}MFFcatcode}), two subsequent
commands {\tt\bs{}MFFcatcode} without intermediate{\tt\bs{}noMFFcatcode}
produce an error: the status of `{\tt \_}' and `{\tt @}' will be
{\em letters} even after the command {\tt\bs{}noMFFcatcode}.
To assign the status {\em other characters} to `{\tt \_}' and `{\tt @}'
unconditionally, the command {\tt\bs{}otherMFFcatcode} can be used.

\bigskip

The only operation that should be performed inside
{\tt\bs{}MFF@assign@{\em varname}} is the re-definition of
{\tt\bs{}@tempdimb}. No {\tt\bs{}@tempdima} nor other
internal variables can be changed although the contents of
{\tt\bs{}@tempdima} and the initial value of {\tt\bs{}@tempdimb}
can be used to calculate the output value. The exception are
the dimensional registers
{\tt\bs{}MFF@dimenA}, {\tt\bs{}MFF@dimenB},
{\tt\bs{}MFF@dimenC}, {\tt\bs{}MFF@dimenD}
which can be used for intermediate calculations.
Also, it is necessary to take into account that:
\begin{itemize}
\item the value of all dimensional {\tt .mf} variables except
      \begin{itemize}\item[]
      {\tt notch\_cut\#}, {\tt cap\_notch\_cut\#},
      {\tt rule\_thickness\#}
      \end{itemize}
      is divided by 36 when printed to the header file;
\item the values of the variables
      \begin{itemize}\item[]
      {\tt notch\_cut\#}, {\tt cap\_notch\_cut\#},
      {\tt rule\_thickness\#}
      \end{itemize}
      are divided by 100 when printed to the header file;
\item the values of non-dimensional variables
      \begin{itemize}
      \item[]\begin{flushleft}
      {\tt fudge}, {\tt math\_spread},
      {\tt superness}, {\tt superpull},
      {\tt beak\_darkness}
      \end{flushleft}\end{itemize}
      are printed to the header file `as it is' but it is to be
      specified in {\tt pt} --- say, to assign
      the value 0.5 to the variable {\tt fudge},
      the command
      \begin{itemize}
      \item[] {\tt \bs{}def\bs{}MFF@assign@fudge\{\bs{}@tempdimb=0.5pt\}}
      \end{itemize}
      should be used;
\item the value of the font parameter {\tt slant} is
      set directly by the commands {\tt \bs{}MFFslant}
      and {\tt \bs{}MFFslantD} and cannot be specified
      using the command {\tt\bs{}MFF@assign@slant};
\item the value of {\tt font\_size} is defined by the parameter
      {\em fntsize} of the command {\tt\bs{}MFFgener}
      (see section~\ref{GENER}) and cannot be changed
      after it.
\end{itemize}


\section{Automatic control of font parameters\label{CORR}}

The \MF{} programs which describe the {\sl Computer Modern} typefaces
assume that the following mutial relations between font parameters
are fulfilled (see \cite{CM} for more details):
\begin{itemize}
\item $0.5\cdot${\tt x\_height} $\le$ {\tt bar\_height}
      $\le 0.55\cdot${\tt x\_height}
\item $\displaystyle\begin{array}[t]{rcl}
      \hbox{\tt asc\_height} &\ge& 1.2\cdot\hbox{\tt x\_height}\\
      \hbox{\tt curve} &\ge& \hbox{\tt stem}\\
      \hbox{\tt cap\_stem} &\ge& \hbox{\tt stem}\\
      \hbox{\tt cap\_curve} &\ge& \hbox{\tt curve}
      \end{array}$
\item
each of the variables
\begin{itemize}
\item[] \begin{flushleft}
        {\tt thin\_join}, {\tt hair}, {\tt vair}, {\tt stem}, {\tt curve},
        {\tt ess}, {\tt flare}, {\tt dot\_size}, {\tt bar}, {\tt slab},
        {\tt cap\_hair}, {\tt cap\_stem}, {\tt cap\_curve},
        {\tt cap\_ess}, {\tt cap\_bar}, {\tt cap\_band}
        \end{flushleft}
\end{itemize}
are no less than {\tt crisp}, {\tt tiny} and {\tt fine};
\item
the variables {\tt stem\_corr} and {\tt vair\_corr}
are no greater than
$\frac{1}{5}$ {\tt cap\_hair},
$\frac{1}{6}$ {\tt stem},
$\frac{1}{4}$ {\tt fudge}$\times${\tt stem}
and $\frac{1}{12}$ {\tt curve};
\item
the variable {\tt vair\_corr} is no greater than
$\frac{1}{4}\hbox{\tt slab}$;
\item
the variable {\tt stem\_corr} is no greater than
$\frac{1}{16}\hbox{\tt fudge}\times\hbox{\tt hair}$.
\end{itemize}

Although even the canonical header files sometimes
violate these conditions,
it is more safe if the font parameters calculated by {\sc mff.sty}
satisfy these relations (especially if the {\sl Computer Modern}
driver files {\tt roman.mf}, {\tt textit.mf}, {\tt csc.mf} are used).
From the other side, several interesting effects can be achieved only
when these relations are violated (provided that the {\tt .mf} file
is still processed by \MF{} without errors).
The automatical correction is switched {\em on} and {\em off}
by the commands:
\begin{description}
\item[\quad{\tt\bs{}MFFcheck}] --- the conditions described above
are checked and the variable values are corrected if necessary;
\item[\quad{\tt\bs{}MFFnocheck}] --- the automatical checking
and correction of the font parameters is switched off although
the condition that some critical parameters
are not negative, is still checked and corrected, if necessary.
\end{description}

\section{Font classes\label{CLASS}}

The NFSS/\LaTeX$2_{\varepsilon}$ classifies \TeX{} font
families in a way which is different from the logical structure
of {\tt .mf} files for {\sl Computer Modern} typefaces.
That is, the {\em italic} and {\sc small caps}
are at the same family {\cmcmr roman} together with
{\cmcmbx bold} and {\cmcmsl slanted} fonts, although they are produced
by different driver files. Similarly, {\cmcmr roman},
{\cmcmtt typewriter}, {\cmcmss sans serif}, {\cmdunh dunhill},
{\cmquote quotation} and {\cmfunny funny} fonts are considered
as different font families
although they are produced by the same driver file {\tt roman.mf}
(but with different font parameters).

As soon as we deal with {\sc mff.sty} there is no sharp boundary
between {\cmcmr roman}, {\cmcmbx bold}, {\cmcmsl slanted},
{\cmcmtt typewriter}, {\cmcmss sans serif}, {\cmfunny funny} and
{\cmdunh dunhill} fonts --- each font is smoothly
converted to another one, while {\em italic} and {\sc small caps}
fonts are quite different --- they use different driver files.
The macros {\sc mff.sty} assign different {\em classes} to these fonts
to distinguish such difference from {\em font families}
used in NFSS. The following font classes can be specified now:
\begin{description}
\item[\quad CMR] --- Computer Modern Roman;
\item[\quad CMTI] --- Computer Modern Text Italic;
\item[\quad CMCSC] --- Computer Modern Small Caps;
\item[\quad DCR] --- European Computer Modern Roman;
\item[\quad DCTI] --- European Computer Modern Text Italic;
\item[\quad DCCSC] --- European Computer Modern Small Caps;
\item[\quad CMRZ] --- {\sl CMZ} Computer Modern Roman/Cyrillic
              created by Nana Glonti and Alexander Samarin;
\item[\quad CMRIZ] --- {\sl CMZ} Computer Modern Text Italic/Cyrillic;
\item[\quad CMCCSC] --- {\sl CMZ} Computer Modern Small Caps/Cyrillic;
\item[\quad LHR] --- {\sl LH} Computer Modern Roman/Cyrillic
              created by Olga Lapko and Alexey Khodulev;
\item[\quad LHTI] --- {\sl LH} Computer Modern Text Italic/Cyrillic;
\item[\quad LHCSC] --- {\sl LH} Computer Modern Small Caps/Cyrillic.
\item[\quad LLR] --- {\sl LL} Computer Modern Roman/Cyrillic
              created by Olga Lapko and Alexey Khodulev
              (cyrillic part only);
\item[\quad LLTI] --- {\sl LL} Computer Modern Text Italic/Cyrillic;
\item[\quad LLCSC] --- {\sl LL} Computer Modern Small Caps/Cyrillic.
\end{description}
The font class is specified by the command
\begin{itemize}
\item[]{\tt \bs{}MFFclass\{{\em class}\}}
\end{itemize}
For example the command {\tt \bs{}MFFclass\{CMR\}}
activates {\sl Computer Modern Roman} fonts
(that is, the font header file will use the driver file
{\tt roman.mf}).

The set of font classes
can be extended easily as soon as there is a font based
on the same set of parameters as {\sl Computer Modern} fonts.
The only thing to do is to specify the macro which writes the
{\tt font\_identifier} value and the operator {\tt generate}
with corresponding name of the driver file (see {\sc mff.sty}
for the examples).

\section{Special Effects\label{TRICKS}}

To make more fun some special effects described in \cite{ABC,Outline}
can be included in your font. If you specify some {\em font trick}
declaration, the special portion of \MF{} code is inserted in the
header file which modifies the characters generated by
original \MF{} subroutines.
The {\em font trick} declarations can specify
\begin{itemize}
\item pattern for the main body of the character;
\item pattern for the rectangular box (background) of the character;
\item pattern for the character shadow (if present);
\item pattern for the underlining of the character (if present)
      [this feature will be realized in future versions];
\item additional transformations (reflections, rotations, etc.)
      of the characters.
\end{itemize}
The command {\tt \bs{}MFFtrick} which specifies these attributes
has the format:
\begin{itemize}
\item[] {\tt \bs{}MFFtrick\{{\em char-style}\}\{{\em box-style}\}%
          \{{\em shadow-style}\}\{{\em underline}\}\{{\em transform}\}}
\end{itemize}
where the parameter {\em underline} is reserved for future
improvements and means nothing in the current version.
The following letters can be used to specify the
{\em char-style}, {\em box-style} and {\em shadow-style}:
\begin{eqnarray*}
&&\hbox{{\tt z} --- no such element or solid white pattern;}\\
&&\hbox{{\tt b} --- solid black pattern;}\\
&&\hbox{{\tt h} --- horizontal stripes;}\\
&&\hbox{{\tt v} --- vertical stripes;}\\
&&\hbox{{\tt r} --- slanted stripes {\tt /};}\\
&&\hbox{{\tt l} --- slanted stripes {\tt \bs};}\\
&&\hbox{{\tt g} --- rectangular grid (`{\tt h}'$+$`{\tt v}');}\\
&&\hbox{{\tt s} --- slanted grid (`{\tt r}'$+$`{\tt l}');}\\
&&\hbox{{\tt d} --- dotted grid.}
\end{eqnarray*}
The capital letters {\tt Z}, {\tt B}, {\tt H}, {\tt V}, {\tt R},
{\tt L}, {\tt G}, {\tt S}, {\tt D}
mean that the outline of the element contour
is added to the filling pattern.
The specifications {\tt b} and {\tt B}
are equivalent since the outlined contour is undistinguishable
over the solid black pattern.
For example, the outlined main character
with a white body, white box background and
outlined shadow filled with dotted grid is specified by the command
{\tt \bs{}MFFtrick\{Z\}\{z\}\{D\}\{\}}.

The parameter {\em transform} specifies the transformation
of the character\footnote{Several transformations can be used
--- in this case the individual letters are separated by commas
like in {\tt\{rr,sx,ro\}}.}:
\begin{eqnarray*}
&&\hbox{{\tt rr} --- rotation $-90^{\circ}$;}\\
&&\hbox{{\tt rl} --- rotation $+90^{\circ}$;}\\
&&\hbox{{\tt ro} --- rotation $180^{\circ}$;}\\
&&\hbox{{\tt sx} --- symmetry $x \longrightarrow -x$;}\\
&&\hbox{{\tt sy} --- symmetry $y \longrightarrow -y$;}\\
&&\hbox{{\tt sz} --- symmetry $(x,y) \longrightarrow (y,x)$,}\\
&&\hbox{{\tt st} --- symmetry $(x,y) \longrightarrow (-y,-x)$.}
\end{eqnarray*}
The font trick effects specified by the command {\tt\bs{}MFFtrick}
are used immediately by the subsequent commands {\tt\bs{}MFFgener}.
The following commands switch {\em on} and {\em of}
the font trick effects provided that the font trick
parameters are already established:
\begin{itemize}
\item[] {\tt \bs{}MFFfonttricks} --- activates
        the font trick declarations;
\item[] {\tt \bs{}MFFnotricks} --- deactivates
        the font trick declarations.
\end{itemize}
The following commands can be used to specify the individual
font trick elements (these declarations are used by the subsequent
commands {\tt\bs{}MFFgener} only after the explicit
command {\tt\bs{}MFFfonttricks} or if they are specified after the
command {\tt\bs{}MFFtrick}):
\begin{description}
\item[\quad{\tt\bs{}trickMFFchar\{{\em char-style}\}}] --- the pattern style
        for filling of the body of the character (``{\tt z}'' means white body);
\item[\quad{\tt\bs{}trickMFFbox\{{\em box-style}\}}] --- the pattern style
        for filling of the background box (``{\tt z}'' means empty background);
\item[\quad{\tt\bs{}trickMFFshadow\{{\em shadow-style}\}}] --- the pattern style
        for filling of the character shadow (``{\tt z}'' means no shadow);
\item[\quad{\tt\bs{}trickMFFtransform\{{\em transform}\}}]
        --- the additional transformation of the character.
\end{description}
Some typical font trick effects can be specified using the
command
\begin{itemize}
\item[] {\tt\bs{}MFFstdtrick\{{\em trick-name}\}}
\end{itemize}
where the following {\em trick-name} identifiers can be used:
\begin{description}
\item[\quad{\tt standard}] --- no font tricks
(={\tt\bs{}MFFtrick\{b\}\{z\}\{z\}\{\}});
\item[\quad{\tt reversed}] --- {\em reversed} characters:
white letters over black rectangle;
\item[\quad{\tt dotted}] --- characters with a body filled with dots;
\item[\quad{\tt striped}] --- characters with a body filled with
rectangular grid;
\item[\quad{\tt stripedH}] --- characters with a body filled with
horizontal stripes;
\item[\quad{\tt stripedV}] --- characters with a body filled with
vertical stripes;
\item[\quad{\tt slanted}] --- characters with a body filled with
slanted rectangular grid;
\item[\quad{\tt slantedL}] --- characters with a body filled with
slanted stripes ``{\tt\bs}'';
\item[\quad{\tt slantedR}] --- characters with a body filled with
slanted stripes ``{\tt/}'';
\item[\quad{\tt outlined}] --- outlined white characters;
\item[\quad{\tt shadowed}] --- outlined white characters
with solid shadows;
\item[\quad{\tt sHadowed}] --- outlined white characters
with outlined white shadows;
\item[\quad{\tt shadowonly}] ---
only the solid shadow of the character is still present.
\end{description}
The parameters of the {\em font trick} effects are controlled
by the commands:
\begin{itemize}

\item outline contour parameters:
\begin{description}
\item[\quad{\tt \bs{}stepMFFoutline\{{\em value}\}}] ---
the thickness of the outline contour.
\end{description}

\item shadow parameters:
\begin{description}
\item[\quad{\tt \bs{}stepMFFshadow\{{\em value}\}}] ---
the step of the shadow shift;
\item[\quad{\tt \bs{}cornerMFFshadow\{{\em char}\}}] ---
the corner of the shadow:
\begin{itemize}
\item[]{\tt A} --- right/down corner;\\
       {\tt B} --- right/upper corner;\\
       {\tt C} --- left/upper corner;\\
       {\tt D} --- left/down corner.
\end{itemize}
\end{description}

\item the parameters for the patterns which are used
      for the main body of the character:
\begin{description}
\item[\quad{\tt \bs{}stepMFFcharpattern\{{\em value}\}}] ---
the step between lines and dots;
\item[\quad{\tt \bs{}penMFFcharpattern\{{\em value}\}}] ---
the thickness of lines and dots.
\end{description}

\item the parameters for the patterns which are used
      for the background of the character:
\begin{description}
\item[\quad{\tt \bs{}stepMFFboxpattern\{{\em value}\}}] ---
the step between lines and dots;
\item[\quad{\tt \bs{}penMFFboxpattern\{{\em value}\}}] ---
the thickness of lines and dots.
\end{description}

\item the parameters for the patterns which are used
      for the character shadow:
\begin{description}
\item[\quad{\tt \bs{}stepMFFshadowpattern\{{\em value}\}}] ---
the step between lines and dots;
\item[\quad{\tt \bs{}penMFFshadowpattern\{{\em value}\}}] ---
the thickness of lines and dots.
\end{description}
\end{itemize}
The values of the thickness/step size for the
striped, slanted and dotted patterns
are specified using the non-dimensional {\em value}
which is the factor applied to the (dimensional)
font parameter {\tt hair\#}. For example,
the command {\tt\bs{}stepMFFboxpattern\{0.5\}}
specifies that the step size between horizontal,
vertical or slanted lines used to
construct the pattern for the background
is equal to $0.5\times${\tt hair\#}.

\section{Default state}

The default values for {\em all} parameters used by {\sc mff.sty}
are assigned by the command {\tt \bs{}MFFdefault} which
is defined as
\begin{itemize}
\item[]\small
\begin{verbatim}
\def\MFFdefault{
%
    \MFFcontrast[s]
    \MFFscaleBoldLines{1}  \MFFscaleThinLines{1}
    \MFFscaleWidth{1}      \MFFscaleHeight{1}
    \MFFscaleAscend{1}     \MFFscaleDescend{1}    \MFFscaleMath{1}
    \MFFscaleJoinLines{1}  \MFFscaleNotchCut{1}
    \MFFscaleDotSize{1}    \MFFscaleSerifDish{1}
%
    \MFFslant{0}
    \MFFflagLigs{s}        \MFFflagMonospace{n}
    \MFFflagSquareDots{n}  \MFFflagHefty{n}
    \MFFflagSerifs{y}      \MFFflagVariantG{n}
    \MFFflagLowAsterisk{n} \MFFflagMathSpacing{n}
%
    \stepMFFoutline{0.075}
    \stepMFFshadow{0.5}
    \cornerMFFshadow{A}
    \stepMFFbackpattern{0.375}    \penMFFbackpattern{0.075}
    \stepMFFcharpattern{0.375}    \penMFFcharpattern{0.075}
    \stepMFFshadowpattern{0.375}  \penMFFshadowpattern{0.075}
%
    \MFFstdtrick{standard}
    \MFFnotricks
%
    \MFFsauter
    \MFFclass{CMR}
    \MFFmixture{0}{0}{0}{0}{0}{0}{0}
    \MFFnocheck
}
\end{verbatim}
\end{itemize}
It can be called at any moment to initialize
from the very beginning the {\sc mff.sty} parameters.


\section{Configuration of {\sf em\TeX} programs\label{CONFIG}}

The way you should setup \TeX\ and \MF\ to work with {\sc mff.sty}
correctly depends on your local system.
The most difficult (and system-dependent) aspect is how to teach
\MF{} to generate the {\tt *.pk}-files according to
your printer specification, and how to teach \TeX\ and
{\sl DVI}-drivers to find \MF's output files.
For {\sl MS DOS} and {\sl OS/2} and for {\sf em\TeX}
package this problem can be solved using the utility {\sl MFJob}
as it is described below.

The configuration used here assumes that the {\tt .mf} files
and {\tt .tfm} files are placed at the working directory, and
the {\tt .pk} files are placed in its subdirectories with the names
corresponding to font resolution. The {\tt .mf} files created
by {\sc mff.sty} are placed at the current directory automatically.
The {\tt .tfm} and {\tt .pk} files are placed at the proper directories
by the utility {\sl MFJob} if it uses the following script file:
\begin{verbatim}
%
% file mff.mfj / script for MFPiC and MFF.STY
%
input [modes];
def s=[s0];
{
base=plain;
fonts=f; mags=s; m;
output=pk[.\@Rrdpi\@f] tfm[@f] log[@f];
}
\end{verbatim}
The script file named {\tt mff.mfj} should be placed at the directory
{\tt\bs{}EMTEX\bs{}MFJOB\bs}.
To process the {\tt .mf} file by \MF{} and to generate the output font
for the desired printer with desired magnification it is necessary
to use the command
\begin{itemize}
\item[]\tt mfjob /a mff.mfj m=$<${\em printer-mode}$>$
                            s=$<${\em magn}$>$
                            f=$<${\em fontname}$>$
\end{itemize}
(option {\tt /a} forces the program to generate the output font even if
it was already generated). The program {\sl MFJob} put {\tt .tfm}
and {.log} files at the current directory, and {\tt .pk} file at
the subdirectory with the name which mirrors the font resolution.
Example:
\begin{itemize}
\item[]\tt mfjob /a mff.mfj m=lj s=1 f=zcmr10
\end{itemize}

To teach {\sf em\TeX} to look for {\tt .tfm} files at the current
directory as well as at the system directories, it is necessary
to specify the DOS environment variable {\tt TEXTFM} as
\begin{itemize}
\item[]\tt SET TEXTFM=\%EMTEXDIR\%\bs{}TFM!;.\bs
\end{itemize}
instead of its default value {\tt \%EMTEXDIR\%\bs{}TFM!}
(it is assumed that {\tt EMTEXDIR}
is specified already like {\tt SET EMTEXDIR=C:\bs{}EMTEX}).

To teach {\sl DVI}-drivers to look for {\tt .pk}
files at the subdirectories of the current directory,
it is necessary to edit the printer configuration files
placed by {\sf em\TeX} at {\tt\bs{}EMTEX\bs{}DATA\bs}.
Suppose you use the {\sl HP Laser Jet} printer (the modifications
of the configuration files for other printers are performed similarly).
The original {\sl Laser Jet} configuration file {\tt lj.cnf}
looks like
\begin{verbatim}
% lj.cnf (300x300 DPI using LJ fonts)
+dvi-file={,$DVIDRVINPUT:}@i
+font-libraries=$DVIDRVFONTS:lj_{base,more}
+font-files=$DVIDRVFONTS:pixel.lj\@Rrdpi\@f{.pk,.pxl}
+graph-files={,$DVIDRVGRAPH:}{@Rrdpi\,}@PBf{@Ef,.msp,.pcx,.bmp}
+resolution=300
+font-resolution=300
+font-scaling=1
+metafont-mode=laserjet
+max-drift=2
\end{verbatim}
The new configuration file (with the file name {\em different}
from {\tt lj.cnf}) should contain the parameter {\tt +font-files}
in a form
\begin{verbatim}
....
+font-files={$DVIDRVFONTS:pixel.lj\,}@Rrdpi\@f{.pk,.pxl}
....
\end{verbatim}
Now it is necessary to substitute the references on this
configuration file in the batch files {\tt v.bat}, {\tt vs.bat}
and {\tt prtlj.bat} from {\tt\bs{}EMTEX\bs{}BIN\bs{}},
and you are ready to work with {\sc mff.sty}.
Just the same re-configuration of {\sf em\TeX} will enable
to work correctly with the {\sl MF\PiC} macro package.

\section{History}
\begin{itemize}
\item Ver. 0.??  --- the first attempt which helped
                     to learn more about \TeX{} commands and
                     the internal structure of
                     {\sl Computer Modern} fonts.
\item Ver. 1.0 --- the arithmetical macros finally works.
                   The ``empirical'' approximation scheme based
                   on linear splines and ``corrected-by-hand''
                   CM parameters is implemented.
                   The fonts generated by command
                   {\tt\bs{}MFFmixture} (at that moment it was called
                   {\tt\bs{}MFFcompose}) are tested experimentally.
\item Ver. 1.1 --- {\sc sauter} approximation scheme is used instead
                   of the ``empirical'' approximation scheme.
                   Commands for the logical flags are added.
                   Font classes other than CMR are included.
                   Generation of {\sc small caps} and
                   {\it italic} fonts is added.
                   As a result new commands are added,
                   some commands are renamed.
\item Ver. 1.2 --- the font tricks described in \cite{ABC} and \cite{Outline}
                   are added.
                   Font classes corresponding to the {\sc DC fonts}
                   driver files are included.
\item Ver. 1.21a --- the approximation based on {\sc DC fonts} data is added.
                   Information printed at the header of {\tt .mf} file
                   becomes more detailed now.
                   The {\sc mff.sty} commands are revised
                   and the names of many commands are changed.
                   This version was distributed during the {\sl TUG-96}
                   Conference.
\item Ver. 1.21b --- the section ``{\em Last minute corrections}''
                   is added to this manual. The obligatory prefix
                   {\em xx} is added now in front of the file name
                   containing the font header. The list of parameters
                   for {\tt\bs{}MFFtrick} is changed so that in future
                   the {\em underlining} effect can be added.
                   This version is put on CTAN.
\end{itemize}

\section{Last minute corrections\label{MORE}}

The following data is the result of discussioins
held during the {\sl TUG-96} Conference.
Some corrections suggested by the participants
are implemented just now, most of them will be
implemented in future versions:
\begin{itemize}
\item {\em Add special (and obligatory) prefix in front of
      the file name so, that the fonts created
      by {\sc mff.sty} cannot be confused with the fonts
      created by the professional font designers.}

      Corrected. Now all the fonts created by {\sc mff.sty} are
      started with {\em xx}. This feature is added to lock the
      attempts to create user-defined fonts under the names of
      the Computer Modern, etc., fonts. The prefix {\em xx}
      used by default is defined as
      \begin{itemize}
      \item[] \tt\bs{}def\bs{}MFFprefix\{xx\}
      \end{itemize}
      and can be redefined by the User, if necessary.

\item {\em Include {\sl Concrete Fonts} into the set of fonts
      used in the arithmetical mixture of Computer Modern
      families.}

      It is not done, and with great probability it will not be done
      at all. The most essential effects associated with
      {\em Concrete Font Family} can be produced in {\sc mff.sty}
      using the scaling of the thickness for
      the thin strokes (see section~\ref{WEIGHT}).

\item {\em Extend {\sc mff.sty} to generate the mathematical fonts as well.}

      This is a very interesting and important suggestion,
      but it requires a lot of time since it is also necessary
      to describe all these fonts as the mathematical ones
      inside \TeX. Will be done somedays in future.

\item {\em Extend {\sc mff.sty} to work with {\sl Pandora Font Family}
      as well.}

      Interesting and promising. It may be done if there
      is enough time to look for for {\sl Pandora Font Family}
      in more details.

\item {\em Generate the partial fonts, i.e., generate the font where
       some (or nearly all) characters from the original MetaFont source
       are excluded.}

       Interesting and not too difficult using the re-definition
       of the procedure {\tt beginchar} by the commands
       inside the font header created by {\sc mff.sty}.
       Some problems may arize due to {\sl Metafont}
       memory problems. Will be done in future.

\item {\em Include some more {\sl font trick} effect, namely the
      underlining of the characters so that the underlining stroke
      has some gaps near the descender of the character.}

      Interesting and not too difficult. Corresponding feature
      is reserved now in the list of {\tt\bs{}MFFtrick} parameters
      (see section~\ref{TRICKS}).
      Will be realized in the nearest future.

\end{itemize}


\section*{Acknowledgements}

This research was partially supported by a grant
from the Dutch Organization for Scientific Research
(NWO grant No 07-30-007).


\begin{thebibliography}{00}
\bibitem{CM} Donald E.\ Knuth. Computer Modern Typefaces
(\CandT{} series). \AW, 1986.
\bibitem{SAUTER} John Sauter. {\em Building Computer Modern fonts}.
\TUB, {\bf 7} (1986), pp. 151--152.
\bibitem{DC} J\"org Knappen. {\em The release 1.2 of the Cork
encoded DC fonts and the text companion symbol fonts}.
  Proceedings of the 9th Euro\TeX{} Conference, Arnhem, 1995.
\bibitem{LL} A.Khodulev, I.Mahovaya.
{\em On \TeX{} experience in MIR Publishers}.
  Proceedings of the 7th Euro\TeX{} Conference, Prague, 1992.
\bibitem{LH} O.Lapko.
  {\em  MAKEFONT as a part of CurTUG--Em\TeX{} package}.
  Proceedings of the 8th Euro\TeX{} Conference, Gda\'nsk, 1994.
\bibitem{ABC} Georgia K.M. Tobin.
      {\em The ABS's of Special Effects}.
      TUGBoat {\bf 9} (1988) No 1 pp. 15--18.
\bibitem{Outline} Doug Henderson.
      {\em Outline Fonts with Metafont}.
      TUGBoat {\bf 10} (1989) No 1 pp. 36--38.
\end{thebibliography}


\end{document}
