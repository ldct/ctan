\documentclass[a4paper]{article}
\usepackage[latin9]{inputenc}
\usepackage[OT1]{fontenc}
\usepackage{sdrt}
\usepackage[margin=3cm]{geometry}
\usepackage{supertabular}
\usepackage{amsfonts}
\usepackage{wasysym}
\usepackage{xytree}
\begin{document}
\title{\textbf{The package} \texttt{sdrt.sty}}\author{Paul Isambert\\zappathustra@free.fr\\http://paulisambert.free.fr/}

\fontfamily{ptm}
\selectfont
\maketitle
\setcounter{section}{-1}

\begin{abstract}
This package is designed to help authors typesetting papers addressing SDRT (Segmented Discourse Representation Theory). Since SDRT is formal semantics, many of the macros in this package will be useful for logic in general (and DRT in particular, of course). Actually, I just wrote some simple macros to make life simpler, and gathered many useful symbols, that I rename for them to be easier to remember and to work both in math mode and in text.
\end{abstract}

\tableofcontents

\section{Installation}
This package must be installed and loaded in the usual way. It requires the \verb+xyling.sty+ package (already available in some \LaTeX\ distribution, like MiKTeK 2.5) to be installed (but not loaded in your preamble), in order to draw trees. If, for some reason, you don't want to download it, just put \% before \verb+RequiresPackage{xyling}+ at the beginning of \verb+sdrt.sty+. You won't be able to draw trees anymore.

Apart from that, \verb+xyling.sty+ uses \verb+xypic+ with the \verb+dvips+ option to draw coloured branches. But then, when building directly to PDF, branches of the tree disappear, which is somewhat annoying. Thus, either you suppress the \verb+dvips+ option in line 57 of \verb+xyling.sty+, keeping in mind that you won't be able to draw coloured branches anymore (and actually all branches will look ugly), or you create your PDF file via DVI PS, for instance (as I did for this documentation: to get everything as nice as possible, especially tables without bold lines, you should convert your .ps file via GSview, using \emph{File}$>$\emph{Convert}, with \emph{Type: pdfwrite}, \emph{Resolution: 300} - better resolution yields ugly tables; finally, don't forget to add the extension .pdf to the name of the output file, since it is not automatic). Anyway, the fine conversion to a PDF file is a problem in itself, to which I don't know any complete solution. For instance, horizontal lines in the boxes of this documentation are sometimes a bit too long in PDF (as can be seen in the first box above), though they are fine in PS, ending exactly at the vertical line.
\section{Boxes}

\subsection{Renaming pi}

In SDRT, clauses are referred to with $\pi$ and a subscript and/or a superscript. Thus, to print, for instance, $\pi^{\prime}_{1}$, one has to write \verb+$\pi^{\prime}_{1}$+, which is not impossible, but boring when typing it ten times a page. So I designed \verb+\lab[]{}+ (for \emph{label}), which takes two arguments, to do the job. In the optional first argument (hence the brackets) you can place as many bars as you want, and the second one refers to the subscript. The subscript might be anything, and if you want none, leave this argument empty (but don't forget the braces). 

Now, most labels have either a superscript, which is rarely more than four bars, or a subscript, which in general is a number from 0 to 9. So I wrote some commands to make life easier. Their names are easy to remember : \verb+\labzero+, \verb+labone+... \verb+labnine+ yield \labzero, \labone... \labnine, and \verb+\labprime+, \verb+\labsecond+, \verb+\labthird+, \verb+\labfourth+ print \labprime, \labsecond, \labthird, \labfourth. This avoids excessive braces, and this will prove useful when building \scshape sdrs\upshape s. However, those commands eats subsequent space. When drawing a box or a tree, this won't be a problem, since in general they're followed by either a punctuation mark or nothing. Thus, no special care is required. On the other hand, in the course of a paragraph, gobbling of subsequent space is always annoying. If you want to use them anyway, a simple solution is to add a backslash at the end of the command. Thus, write \verb+\labone\ is fine+ to yield `\labone\ is fine'. Of course, don't use that backslash before a punctuation mark.

\subsection{Building SDRSs}
\subsubsection{Boxes}
An SDRS look like this: 
\begin{center}
\SDRS{\labzero}{\SDRS[\labzero]{\labone, \labsecond}{\klabone, Elaboration(\labone, \labsecond)\\\SDRS[\labsecond]{\labtwo, \labfive, \labprime}{\klabstartwo, \klabstarfive,\\Narration(\labtwo, \labfive)\\Elaboration(\labtwo, \labprime)\\\SDRS[\labprime]{\labthree, \labfour}{\klabstarthree, \klabstarfour\\Narration(\labthree, \labfour)}}}}
\end{center}
(This is the famous ``Max's great night'' example.) We need the following command: \verb+\SDRS+\footnote{\texttt{$\backslash$drs} and \texttt{$\backslash$sdrs} were part of the \texttt{covington.sty} package. I modified the code slightly and rewrote it for \texttt{sdrt.sty}, since I wanted better alignment in the boxes and generalized math mode. Moreover, \texttt{$\backslash$sdrs} just printed a sentence above the box, and didn't handle what \texttt{$\backslash$SDRS} does. Finally, my command is written in capital letters, so it won't conflict with \texttt{$\backslash$sdrs} if you also use \texttt{covington.sty}.}. It takes two mandatory argument and an optional one. In the first mandatory argument, you put the so-called Universe of the (S)DRS (that is, the upper part of the box), and in the second one, the Conditions (the lower part of the box). Thus, \verb+\SDRS{Universe}+ \verb+{Conditions}+ will yield:
\begin{center}
\SDRS{Universe}{Conditions}
\end{center}
In the Universe and in the Conditions, you can put commas between the elements. However, although there is no big risk with the Universe, you might create ugly long lines in the Conditions, so you'd better break them with \verb+\\+. So, instead of \verb+\SDRS{Universe}+\verb+{Condition1, Condition2+, \verb+Condition3, Condition4}+, which gives:
\begin{center}
\SDRS{Universe}{Condition1, Condition2, Condition3, Condition4}
\end{center}
write \verb+\SDRS{Universe}+\verb+{Condition1, Condition2,\\+\verb+Condition3, Condition4}+ and you'll get :
\begin{center}
\SDRS{Universe}{Condition1, Condition2,\\ Condition3, Condition4}
\end{center}
Moreover, Conditions in SDRT are on their own line in general, though you may put two on the same to save space. Whatever you decide, remember that legibility must be the rule, hence always write a condition containing another sub-box on a line alone, just like in the example above.

The optional argument (between brackets) is the label which is defined by the box. Thus, \newline \verb+\SDRS[\labone]{Universe}{Conditions}+ for example prints the following:
\begin{center}
\SDRS[\labone]{Universe}{Conditions}
\end{center}
Of course, you can put any structure into another one by writing it among the Conditions. So, for example, you can write \verb+\SDRS{\labone}{\SDRS[\labone]+\verb+{Universe}{Conditions}}+ and yield:
\begin{center}
\SDRS{\labone}{\SDRS[\labone]{Universe}{Conditions}}
\end{center}

Now, you have to be aware of the fact that everything in (S)DRSs is in math mode. And in math mode, everything is in italics and spaces between words is suppressed. It is exactly what we need when drawing usual (S)DRSs, but this might be problematic if we want something like this:

\begin{center}
\SDRS{\labone}{\labone: [$John loves Mary$]}
\end{center}
If we just write \verb+\SDRS{\labone}{\labone: [John loves Mary]}+, well, this will yield:

\begin{center}
\SDRS{\labone}{\labone: [John loves Mary]}
\end{center}
All we have to do is to add \$'s around the sentence. Since math mode is defined by \$...\$ (automatically in this package), it is obvious that embedding another pair of \$'s in the latter will produce two math modes with text mode in between. Thus, just write \verb+\SDRS{\labone}{\labone: [$John loves Mary$]}+ and everything will be fine. On the other hand, never write something like \verb+$\alpha$+ in a (S)DRS, since it would suppress the math mode greek letters need, for exactly the same reason. So just remember that (S)DRS are `automatic math environment'.

\subsubsection{Conditions}
Now, we can build boxes as we want. But we must be able to write conditions of the form \klabtwo easily. The command for this is \verb+\klab+, which works just like \verb+\lab+, i.e. takes two arguments, one for the superscript (optional) and one for the subscript. Thus, \klab{2} is typed out with \verb+\klab{2}+. Just like \verb+\lab+, \verb+\klabzero+, \verb+\klabone+... \verb+\klabnine+ will print \klabzero, \klabone... \klabnine. There is also the `starred' version, when some underspecification is at stake : \klabstar{3}. So there's the code \verb+\klabstar+, which works exactly like \verb+\klab+, with the easy version too, that is \verb+\klabstarzero+, \verb+\klabstarone+, and so on\footnote{I didn't designed \texttt{$\backslash$klabprime} or \texttt{$\backslash$klabstarprime} an so on like I did with \texttt{$\backslash$labprime}, since barred labels in general refer to SDRSs and not to clauses. But they are easy to write with the \texttt{$\backslash$klab} or \texttt{$\backslash$klabstar} commands : \texttt{$\backslash$klabstar[''']\{\}} for instance will print \klabstar[''']{}.}. 

Finally, conditions of the form $Narration(\labtwo, \labfive)$ are simply written with \verb+Narration(\labtwo, \labfive)+. Since (S)DRSs are in math mode, you don't need to emphazise the name of the relation. This also means that in the course of your text, you have to add math mode, hence \verb+$Narration(\labtwo, \labfive)$+ to yield the same thing. If the arguments of you relation have only subscripts, there is a command, namely \verb+\dr{Relation}{subscript1}{subscript2}+, which automatically produce the right form. Thus \verb+\dr{Narration}{3}{5}+ yields \dr{Narration}{3}{5} in any environment. 

\subsubsection{Back to our example}
With all these commands, we can build our example. Here is the code with the result :
\noindent
\begin{verbatim}
\SDRS{\labzero}
      {\SDRS[\labzero]
         {\labone, \labsecond}{\klabone, Elaboration(\labone, \labsecond)\\
         \SDRS[\labsecond]
            {\labtwo, \labfive, \labprime}{\klabstartwo, \klabstarfive,\\
            Narration(\labtwo, \labfive\\
            Elaboration(\labtwo, \labprime)\\
            \SDRS[\labprime]
               {\labthree, \labfour}{\klabstarthree, \klabstarfour\\
               \dr{Narration}{3}{4}}}}}
\end{verbatim}
\begin{center}
\SDRS{\labzero}{\SDRS[\labzero]{\labone, \labsecond}{\klabone, Elaboration(\labone, \labsecond)\\\SDRS[\labsecond]{\labtwo, \labfive, \labprime}{\klabstartwo, \klabstarfive,\\Narration(\labtwo, \labfive)\\Elaboration(\labtwo, \labprime)\\\SDRS[\labprime]{\labthree, \labfour}{\klabstarthree, \klabstarfour\\\dr{Narration}{3}{4}}}}}
\end{center}
This might seem complicated at first sight, but actually it's rather easy if you pay attention to braces. Of course you don't need to write the code with all these indents like I did here for visual convenience. 

\subsubsection{Some more stuff}
There is a `presupposed' version of \verb+SDRS+ to produce boxes like the following:
\begin{center}
\PSDRS{x, \varsub{e}{3}}{dog(x)\\own(\varsub{e}{3}, j, x)}
\PSDRS[\lab{d}]{x, \varsub{e}{3}}{dog(x)\\own(\varsub{e}{3}, j, x)}
\end{center}
\verb+\PSDRS+ is that command, and it works just like \verb+\SDRS+, taking the same three arguments. If you want to use presupposition in text, type \verb+\pres+, which takes one argument : for instance, \verb+\pres{\varsub{K}{\lab{p}}}+ yields \pres{\varsub{K}{\lab{p}}}.

In this latter code there is an additional command \verb+\varsub{}{}+. It is useful to type any kind of variable (or actually anything else) with a subscript. The first argument is the variable, the second is the subscript. Of course, it is recursive, so you can typeset \varsub{A}{\varsub{B}{\varsub{C}{D}}} with \verb+\varsub{A}{\varsub{B}{\varsub{C}{D}}}+. Thus, \varsub{e}{3} in the boxes above is produced by \verb+\varsub{e}{3}+.

Finally, predicates are created like discourse relations, that is \verb+own(\varsub{e}{3},j,x)+ for instance (if you aren't in a (S)DRS, you must add math mode, of course, to get the italics, or add them yourself). Note that you don't have to add a space after the comma, since math mode handle it as needed. Now we can produce an SDRS like the following:
\begin{center}
\SDRS{\labsecond}{\SDRS[\labsecond]{\lab{d}}{\PSDRS[\lab{d}]{x, \varsub{e}{3}}{dog(x)\\own(\varsub{e}{3},j,x)}\\R(u, v)\\R=?\ u=?\ v=?\\i-scopes(\labsecond, \lab{d})}}
\end{center}
Here is the code:
\begin{verbatim}
\SDRS{\labsecond}
     {\SDRS[\labsecond]
          {\lab{d}}{\PSDRS[\lab{d}]
               {x, \varsub{e}{3}}{dog(x)\\
               own(\varsub{e}{3},j,x)}\\
          R(u, v)\\
          R=?\ u=?\ v=?\\
          i-scopes(\labsecond, \lab{d})}}
\end{verbatim}
Note that $\backslash$ is necessary between $R=?$, $u=?$ and $v=?$, otherwise math mode will eat spaces between those conditions.

\section{Trees}
\subsection{The commands}
The most powerful package I know to draw trees is Ralf Vogel's \texttt{xyling.sty}. It is powerful but it needs some care. For instance, you can't produce an SDRT tree without adjusting the length of the branches and the alignment of the labels, otherwise you get something like this :
\begin{center}
\Tree{&&\K{\labzero}\B{d}\\
&&\K{\labone}\AR{d}^{Elaboration}\\
&&\K{\labsecond}\B{dl}\B{dr}\\
&\K{\labtwo}\D\AR{rr}^{Narration}&&\K{\labfive}\\
&\K{\labprime}\DL\DR\\
\K{\labthree}\AR{rr}^{Narration}&&\K{\labfour}\\}
\end{center}
Obviously, that's not what we want to do. So I wrote some macros with the right adjustment. Before devising them, we need to know how exactly \texttt{xyling} works (for details, see the documentation of that package). A tree is made of nodes placed in a grid, which is like a tabular : \& marks the passage to another column, while \verb+\\+ begins another row. Here is an example to compare the output with the underlying grid:
\begin{center}
\begin{tabular}{c c}
\Tree{&\K{A}\\\K{B}&&\K{C}}&
\begin{tabular}{c}
\\\\\\\Large
\verb+      &  A  &   \\+\\
\\\\\Large
\verb+ B  &     &  C+
\normalsize
\end{tabular}
\end{tabular}
\end{center}

In general, the code for the branches is written with the starting node (the mother or the leftmost sister), and the target node is specified as an argument. Now, here are the commands. \verb+\sdrtree{}+ is a kind of environment. The argument is the structure of the tree. \verb+\LAB{}+ denotes the node, whose name is the argument. Thus, for instance, with 
\begin{center}
\begin{verbatim}
\sdrtree{          
                 &\LAB{\labzero}  \\
                 &\LAB{\labone}  \\
\LAB{\lab['']{p}}&              &\LAB{\labsecond}
}
\end{verbatim}
\end{center}
we produce the following tree (I displayed the code with spaces for visual convenience, but of course you could write it on a single line with no space at all... although such a presentation avoids many errors with big trees):
\begin{center}
\sdrtree{&\LAB{\labzero}\\&\LAB{\labone}\\\LAB{\lab['']{p}}&&\LAB{\labsecond}}
\end{center} 
Now we have to draw branches. \verb+\cons+ draws a vertical line from the mother (like \labzero\ in this example) to the sister (like \labone). \verb+\consl+ draws a line between a mother and a sister on the left (like between \lab{1} and \lab['']{p}) and \verb+\consr+ does the same with a sister on the right (like \labsecond\ if \lab{1} is the mother). \verb+\srel{}+, \verb+\srell{}+ and \verb+\srelr{}+ work the same, except that they draw an arrow from the starting node to the target, and take an argument, which is the name of the (subordinating) discourse relation between the labels at the nodes\footnote{If there is a subordinating relation between, say \labone\ and \labtwo, and the same relation between \lab{1} and \lab{3}, usually in SDRT this relation holds between \lab{1} and an intermediate label like \labprime, which in turn is made of \lab{2} and \lab{3} linked by at least a \emph{Continuation} relation. So, in general, we have the first tree below but not the second one:\\\sdrtree{&\LAB{\labone}\srel{Relation}\\&\LAB{\labprime}\consl\consr\\\LAB{\labtwo}\crel{Continuation}&&\LAB{\labthree}}\sdrtree{&\LAB{\labone}\srell{Relation}\srelr{Relation}\\\LAB{\labtwo}\crel{Continuation}&&\LAB{\labthree}}\\Thus, \textit{$\backslash$srell} and \textit{$\backslash$srelr} should be useless. But they aren't, since the analysis above might be discussed or at least might use trees like the second one to illustrate the demonstration.}. Finally, \verb+\crel{}+ draws a horizontal arrow between two sisters with the name of the (coordinating) relation as the argument. Then, with the following code we have the following tree:
\begin{center}
\begin{verbatim}
\sdrtree{          
                                    &\LAB{\labzero}\srel{Explanation}  \\
                                    &\LAB{\labone}\consl\consr  \\
\LAB{\lab['']{p}}\crel{Continuation}&                                &\LAB{\labsecond}
}
\end{verbatim}
\sdrtree{&\LAB{\labzero}\srel{Explanation}\\&\LAB{\labone}\consl\consr\\\LAB{\lab[''	]{p}}\crel{Continuation}&&\LAB{\labsecond}}
\end{center}
And here is the tree drawn from our first big box:
\begin{center}
\sdrtree{&&\LAB{\labzero}\cons\\
&&\LAB{\labone}\srel{Elaboration}\\
&&\LAB{\labsecond}\consl\consr\\
&\LAB{\labtwo}\cons\crel{Narration}&&\LAB{\labfive}\\
&\LAB{\labone}\consl\consr\\
\LAB{\labthree}\crel[rr]{Narration}&&\LAB{\labfour}\\
}
\end{center}
And here is the code: 
\scriptsize
\begin{verbatim}
\sdrtree{                          &                                  &\LAB{\labzero}\cons\\
                                   &                                  &\LAB{\labone}\srel{Elaboration}\\
                                   &                                  &\LAB{\labsecond}\consl\consr\\
                                   &\LAB{\labtwo}\cons\crel{Narration}&                                  &\LAB{\labfive}\\
                                   &\LAB{\labone}\consl\consr\\
\LAB{\labthree}\crel[rr]{Narration}&                                  &\LAB{\labfour}\\
}
\end{verbatim}
\normalsize

\subsection{The problem}
We can see that the code for a tree graphically simulates the structure of that tree: for instance, \labzero\ in the previous example is above \labone, which can be seen from the fact that they have the same number of \&'s on the left. On the other hand, \labtwo\ is a left sister of \labsecond, and thus is one column left, i.e. \labsecond\ have one more \& on its left. This is convenient, but it is also problematic. \verb+xyling.sty+, and thus \verb+sdrt.sty+, does not handle possible conflicts between nodes. To illustrate this, observe the following grid:

\large
\begin{verbatim}
    &   & A &   &
    & B &   & C &
  D &   & X &   &	E
\end{verbatim}
\normalsize
Obviously, X is B's right daughter and C's left one at the same time. If we create a tree with that structure, i.e. if we type the following code:
\footnotesize
\begin{verbatim}
\sdrtree{     &                         &\LAB{\labone}\consl\consr\\
              &\LAB{\labtwo}\consl\consr&                            &\LAB{\labthree}\consl\consr\\
\LAB{\labfour}&                         &\LAB{\lab{}{X}}             &                             &\LAB{\labfive}\\
}
\end{verbatim}
\normalsize
we produce the following tree:
\begin{center}
\sdrtree{      &                         &\LAB{\labone}\consl\consr\\
              &\LAB{\labtwo}\consl\consr&               &\LAB{\labthree}\consl\consr\\
\LAB{\labfour}&                         &\LAB{\lab{X}}&                             &\LAB{\labfive}\\
}
\end{center}
It is a nice tree but ovbiously not of the kind that we need. So the question is: how can we draw a right daughter for \lab{2} and a left one for \lab{3} without merging them together? The answer is straightforward: add columns. That is, create the following grid:

\large
\begin{verbatim}
    &   &   & A &   &   &
    & B &   &   &   & C &
  D &   & X &   &	Y &   & E
\end{verbatim}
\normalsize
Up to now, this is ok. But branches have to be adjusted, otherwise they won't be able to reach their target. For instance, \verb+\consl+ starting from A won't reach B, but the position on the right of it (and an error message will be displayed, since there is no node here). Likewise, you won't be able to draw an arrow from B to C without modification. That is why \verb+\cons+, \verb+\srel+ and \verb+\crel+ all have an optional argument between brackets. This argument is made of d's, l's and r's for `down', `left' and `right' respectively: that's all we need to find the target. One d and you go down one row, two d's and you go down two rows, three r's and you go three columns right... In the grid above B is two columns left from A and one row below. So if you want a simple line from A to B, you type \verb+\cons[dll]+ next to A's node. If you want an arrow from B to C, you write \verb+\crel[rrrr]{Relation}+ next to B. Here is an example:
\begin{center}
\sdrtree{&&&\LAB{\labone}\cons[dll]\srel[drr]{Relation}\\
&\LAB{\labtwo}\consl\srelr{Relation}\crel[rrrr]{Relation}&&&&\LAB{\labthree}\consl\consr\\
\LAB{\labfour}\crel{Relation}&&\LAB{\labfive}&&\LAB{\labsix}\crel{Relation}&&\LAB{\labseven}\\
}
\end{center}
And here is the code:
\begin{verbatim}
\sdrtree{&&&\LAB{\labone}\cons[dll]\srel[drr]{Relation}\\
&\LAB{\labtwo}\consl\srelr{Relation}\crel[rrrr]{Relation}&&&&\LAB{\labthree}\consl\consr\\
\LAB{\labfour}\crel{Relation}&&\LAB{\labfive}&&\LAB{\labsix}\crel{Relation}&&\LAB{\labseven}\\
}
\end{verbatim}
Of course, if \lab{5} had a right daughter and \lab{6} a left one, they would both be in the same column as \lab{1} and thus would merge together. In fact, you have to calculate  the relative position of the nodes \emph{before} you draw the tree, in order to know how many columns will be used. Fortunately, trees for discourse structures aren't syntactic trees and are in general far more simple, so drawing them is rather easy. 

\subsection{Definitions of the commands}
(This section might be skipped if you don't want to know how trees are defined in terms of the \verb+xyling.sty+ package and how to modify the adjustment.)

Here is the code for the commands above.
\begin{verbatim}
\newcommand{\sdrtree}[1]{\Treek[1]{2}{#1}}
\newcommand{\LAB}[1]{\K{ #1}}
\newcommand{\cons}[1][d]{\Bk{.5}{-2}{#1}}
\newcommand{\consl}{\Bk{1}{-2}{dl}}
\newcommand{\consr}{\Bk{1}{-2}{dr}}
\newcommand{\srel}[2][d]{\ARk{.5}{-2}{#1}^{$#2$}}
\newcommand{\srell}[1]{\ARk{1}{-2}{dl}_{$#1$}}
\newcommand{\srelr}[1]{\ARk{1}{-2}{dr}^{$#1$}}
\newcommand{\crel}[2][rr]{\GBkk{3,2.5}{-1.7,-3.5}{#1}{->}_{$#2$}}
\end{verbatim}
I defined \verb+\sdrtree+ to have good-looking depth and width of the tree. If you want to modify them because they aren't satisfying to you, use \verb+\Treek[width]{depth}{tree}+ instead. For instance, here's the previous tree with a modified width:	
\begin{center}
\Treek{2}{&&&\LAB{\labone}\cons[dll]\srel[drr]{Relation}\\
&\LAB{\labtwo}\consl\srelr{Relation}\crel[rrrr]{Relation}&&&&\LAB{\labthree}\consl\consr\\
\LAB{\labfour}\crel{Relation}&&\LAB{\labfive}&&\LAB{\labsix}\crel{Relation}&&\LAB{\labseven}\\
}
\end{center}
I just replaced \verb+\sdrtree+ with \verb+\Treek{2}+: since the width is an optional argument, not specifying it makes it 0. Thus, \verb+\Treek{2}+ is equivalent to \verb+\Treek[0]{2}+. Note that negative values are allowed. 

\verb+\cons+, \verb+\consl+\verb+\consr+ are made of \verb+\Bk+ which takes three arguments: vertical alignment of the starting node, vertical alignment of the target, and the direction as discussed above. \verb+ARk+ works the same. Finally, \verb+\GBkk+, which is used to define \verb+\crel+, has the following structure: the first argument specify the horizontal and vertical alignment of the starting node (seperated by a comma), the second argument specify the same thing for the target, the third argument is the direction, the fourth is the form of the arrow, and the last is the name of the relation. Finally, notice that \verb+\LAB+ has a space before its argument. In \verb+xyling+, nodes are centered, but that centering don't look good with \lab{} when it has a superscript or a subscript. That extra space makes it look better, although it won't be nice with a bare \lab{}. In general, nodes in SDRT all have a sub- or superscript, so it's fine. However, if you don't want that space, juste use the original \verb+\K+ command, which is the usual one for nodes in \verb+xyling+. Finally, note that the name of the relations are in math mode to get the right italics.

\section{List of symbols used in SDRT}

\subsection{Notation index}
I won't explain every symbol. Rather, I will reproduce the `notation index' of Asher \& Lascarides' \emph{Logics of Conversation}, with the corresponding code. Comments in the left column are theirs.
\begin{center}
\tabletail{\hline}
\tablehead{\hline}
\begin{mpsupertabular}{|p{5cm}|p{2.5cm}|p{6cm}|}
\hline
\multicolumn{3}{|c|}{\textbf{1. Information Content: Object Language}}\\
\hline
Variables denoting individuals&$x$, $y$,...&Use \verb+$x$+, \verb+$y$+ and so on (math mode is useless in a (S)DRS, since it is automatically in math mode). If there is a subscript, use \verb+\varsub{variable}{subscript}+.\\
\hline
Variables denoting eventualities&\varsub{e}{1}, \varsub{e}{2},...&Use \verb+\varsub{variable}{subscript}+.\\
\hline
Action terms&\varsub{a}{1}, \varsub{a}{2},...&Use \verb+\varsub{variable}{subscript}+.\\
\hline
Propositional terms&$p$, \varsub{p}{1},...&Use \verb+\varsub{variable}{subscript}+ or simply \verb+$p$+.\\
\hline
The logical connectives and operators&&I did not write any special macro for these, since they are very common. Moreover, a new command usually gobbles subsequent space and might conflict with other existing commands (since they're renamed in many packages). Don't forget math mode, or \LaTeX\ will moan, except in a (S)DRS.\\ 
&$\wedge$&\verb+$\wedge$+\\
&$\vee$&\verb+$\vee$+\\
&$\Rightarrow$&\verb+$\Rightarrow$+\\
&$>$&\verb+$>$+ (if you don't use math mode it will produce >).\\
&$\neg$&\verb+$\neg$+\\
&$\square$&\verb+$\square$+ (you have to load the \verb+amsfonts+ package in your preamble)\\
&$\Diamond$&\verb+$\Diamond$+ (you have to load the \verb+wasysym+ package in your preamble)\\
\hline
The proposition expressed by the formula $K$&\intens{K}&\verb+\intens{K}+ or anything you want in the argument.\\
&&\\
This symbol is not in the `notation index' but it is the counterpart of the previous one, so it might be useful in formal semantics in general&\extens{K}&\verb+\extens{K}+ or anything you want as the argument.\\
\hline
(S)DRSs&\varsub{K}{1}, \varsub{K}{2},...&Use \verb+\varsub{variable}{subscript}+.\\
\hline
The universe of discourse referents of the DRS $K$&\varsub{U}{K}&\verb+\varsub{U}{K}+.\\
\hline
The set of conditions of the DRS $K$&\varsub{C}{K}&\verb+\varsub{C}{K}+. Of course, with this one or the previous one, you could type something like \varsub{C}{\lab[']{2}} by putting \verb+\lab[]{}+ in the second argument hole.\\
\hline
The action of bringing it about that $K$ is true&\true{K}&\verb+\true{K}+ or anything you want as the argument.\\
\hline
A formula, conveying: if $a$ (or \true{K}) is performed, the $\phi$ necessarily (or possibly for \possib{a}{\phi}) follows.&\necess{a}{\phi},  \necess{\true{K}}{\phi}, \possib{a}{\phi}, \possib{\true{K}}{\phi}&\verb+\necess{a}{\phi}+ and \verb+\possib{a}{\phi}+\\
\hline
$K$ is a DRS, $\gamma$ is a DRS condition, and $\append{K}{\gamma}\varsub{=}{def} \langle \varsub{U}{K}, \varsub{Con}{K} \cup \gamma\rangle$&\append{K}{\gamma}&\verb+\append{K}{\gamma}+. $\varsub{=}{def}$ is just \verb+\varsub{=}{def}+, $\langle$ and $\rangle$ are \verb+\langle+ and \verb+\rangle+, all of them in math mode.\\
\hline
A DRS which summarises the content in $K$ and $K'$&$K \summary K'$&\verb+\summary+\\
\hline
labels for DRSs and action terms&$\alpha, \beta,...$, \lab{1}, \lab{2},...&Use greek letters (in math mode) or \verb+\lab+\\
\hline
An SDRS: $A$ is a set of labels, $\mathcal{F}$ is a function which assigns labels in $A$ SDRS-formulae, ans $LAST \in A$&\aflast&\verb+\aflast+. $A$ and $LAST$ are of course the same letters in math mode, while $\mathcal{F}$ is \verb+$\mathcal{F}$+, and $\in$ is \verb+$\in$+\\	
\hline
\end{mpsupertabular}
\end{center}
\textbf{About $\mathcal{F}$}: An expression like \flab{2} may be useful. So we have \verb+flab[]{}+, which works once again exactly like \verb+\lab+, i.e. optional primes as the first argument and subscript as the second. Similarly, \verb+\fklab[']{2}+, for instance, yields \fklab[']{2}, just like \verb+\klab[]{}+. Finally, there is also an `easy' version for both of them, namely \verb+\flabone+, \verb+\flabtwo+... \verb+\flabnine+ and \verb+\fklabone+, \verb+\fklabtwo+... \verb+\fklabnine+. They also eats subsequent space, so use $\backslash$ (e.g. \verb+\flabnine\+) when needed.

Now, let's get back to our notation index:
\begin{center}
\tabletail{\hline}
\tablehead{\hline}
\begin{mpsupertabular}{|p{5cm}|p{2.5cm}|p{6cm}|}
\hline
The formula \flab{\alpha}, that's labelled by $\alpha$&\varsub{K}{\alpha}&Use \verb+\varsub+. No math mode needed for $\alpha$, since \verb+varsub+ automatically launches it when needed.\\
\hline
The main eventuality that's introduced in \varsub{K}{\alpha}&\varsub{e}{\alpha}&Use \verb+\varsub+\\
\hline
Rhetorical relations&\topic, \emph{Narration}, \emph{Contrast},...&\topic\ is produced by \verb+\topic+, but it gobbles subsequent space. So add a $\backslash$ when it might be a problem. Other relations are just text in math mode.\\
\hline
The disputed counterpart to the relation $R$&$Dis(R)$&Simply \verb+Dis(R)+ in math mode, i.e. \verb+$Dis(R)$+.\\
\hline
Label $\phi$ labels formula $K$ (i.e., $\flab{} = K$)&$\lab{} : K$&This `bare' version is simply \verb+$\lab{} : K$+. For more elaborated stuff (i.e. with sub- and/or superscript), use \verb+\klab+ and \verb+\klabstar+.\\
\hline
The formula representing the `extra content', over and above \varsub{K}{\alpha} and \varsub{K}{\beta}, that must be true (or, more accurately, that must update the context) for $R(\alpha, \beta)$ to update the context&$\varsub{\phi}{R}(\alpha, \beta)$&\verb+\varsub{\phi}{R}(\alpha, \beta)+ in math mode.\\
\hline
An individual term denoting the agent who conveyed/uttered the content that's labelled $\alpha$&$S(\alpha)$&\verb+S(\alpha)+ in math mode\\
\hline
Agent $A$ believes that $K$&\believes[K]{A}&\verb+\believes[content]{agent}+. The content is optional since we will need \believes{A} later. By the way, $\mathcal{B}$ is produced with \verb+\mathcal{B}+ in math mode.\\
\hline
Agent $A$ intends the action $a$&\intends[a]{A}&\verb+\intends[action]{agent}+. the action is optional for the same reason as above. $\mathcal{I}$ is produced with \verb+\mathcal{I}+ in math mode.\\
\hline
The speech act related goal of the utterance labelled $\alpha$ is the action \true\extens{p}&\sarg{\alpha}{p}&\verb+\sarg{\alpha}{p}+. This command won't work in math mode, because of small capitals. So, although you might never use it, here is the code:

\verb+\scshape sarg\upshape\ensuremath{(#1, #2)}+. When in math mode, just add a \$ before \verb+\scshape+ and between \verb+\upshape+ and \verb+\ensuremath+.\\
\hline
\multicolumn{3}{|c|}{\textbf{2. Information Content: Metalanguage}}\\
\hline
Possible worlds (in the model)&$w, w'$, \varsub{w}{1}, \varsub{w}{2},...&Use \verb+$w$+, \verb+$w'$+ or \verb+\varsub+.\\
\hline
Variable assignment functions&$f, g,...$&Use math mode.\\
\hline
The domaine of $f$&$dom(f)$&\verb+dom(f)+ in math mode.\\
\hline
$g$ extends $f$. 

I.e., $dom(f) \subseteq dom(g)$ and $\forall x \in dom(f), f(x) = g(x)$&$f \extends g$&Write \verb+f \extends g+. By the way, the code for $\forall x$ is \verb+\forall x+ and the one for $\exists x$ is \verb+\exists x+, both in math mode.\\
\hline
The formula (or action term) $K$ relates the input context $(w, f)$ with the output context $(w', g)$&\tiny \ccp[M]{w, f}{K}{w', g}\normalsize&Use \footnotesize\verb+\ccp[optional world index]+ \verb+{input pair}{formula}{output pair}+\normalsize. If you happen to need \Lbracket and \Rbracket, I designed \verb+\Lbracket+ and \verb+Rbracket+, so you won't have to load any package.\\
\hline
$\Gamma$ monotonically entails $\phi$ (model theory)&$\Gamma \entm \phi$ or $\Gamma \entm[f] \phi$&Use \verb+\entm[]+ whose optional argument is the subscript.\\
\hline
$\Gamma$ monotonically entails $\phi$ (proof theory)&$\Gamma \entp \phi$ or $\Gamma \entp[f] \phi$&Use \verb+\entp[]+ whose optional argument is the subscript.\\
\hline
\multicolumn{3}{|c|}{\textbf{3. Underspecified Information Content: The Language \lulf}}\\
\hline
&&First of all, \lulf\ is typed with \verb+\lulf+, which eats subsequent space, so use an extra $\backslash$.\\
\hline
The translation function form the \scshape ulf\upshape s to the unlabelled language&$\trfunc$&\verb+\trfunc+\\
\hline
Labels&\varsub{l}{1}, \varsub{l}{2},...&Use \verb+\varsub+.\\
\hline
Variables over labels&\varsub{?}{1}, \varsub{?}{2},...&Use \verb+\varsub+.\\
\hline
Higher order variables&$X, Y, R...$&\verb+X, Y, R+ in math mode or \verb+\varsub+ if there is a subscript.\\
\hline
The predicate corresponding to the constructor $f$ from the base (unlabelled) language&\varsub{R}{f}&Use \verb+\varsub+.\\
\hline
A notational variant of \varsub{R}{f}(\varsub{l}{1},..., \varsub{l}{n+1}), where \varsub{l}{i} labels \varsub{x}{i}, $1\leq i\leq n$; e.g., $l: \wedge(p,q)$ is shorthand for \varsub{R}{\wedge}(\varsub{l}{q}, \varsub{l}{p}, l) $\wedge$ $p$(\varsub{l}{p}) $\wedge$ $q$(\varsub{l}{q})&\varsub{l}{n+1} : $f$(\varsub{x}{1},..., \varsub{x}{n})&All those notations are just an efficient use of \verb+varsub+. Note that you can write anything as the second argument, so for instance \verb+\varsub{R}{\wedge}+ produce \varsub{R}{\wedge}.\\
\hline
Gloss for $\exists Y$(\varsub{R}{=}(\varsub{l}{x}, \varsub{l}{y}, $l$) $\wedge$ \varsub{R}{x}(\varsub{l}{x}) $\wedge$ $Y$(\varsub{l}{y}))&$x =?$&Simply \verb+$x =?$+, and once again \verb+varsub+ for the notations in the left column.\\
\hline
Label $l$ outscopes $l'$&$l\outscopes l'$&\verb+\outscopes+.\\
\hline
The conditions in $l$ are accessible to those in $l'$&$l\varsub{\outscopes}{a} l'$&\verb+\varsub{\outscopes}{a}+\\
\hline
\multicolumn{3}{|c|}{\textbf{4. Underspecified Information Content: Metalanguage}}\\
\hline
The set of all labels in the model&$U$&Just \verb+U+ in math mode.\\
\hline
Successor relation on labels (corresponds to \emph{immediately outscopes}).&\varsub{Succ}{}, \varsub{Succ}{D}&Use \verb+Succ+ in math mode or \verb+\varsub+.\\
\hline
The interpretation fonction&$I$&Just \verb+I+ in math mode.\\
\hline
The satisfaction relations of the labelled language (this is different from \entm[f])&\entm[l]&\verb+\entm[l]+.\\
\hline
\multicolumn{3}{|c|}{\textbf{5. Glue Logic: Object Language}}\\
\hline
A \scshape ulf \upshape (which in the glue language forms a one-place predicate)&$\ulf$&\verb+\ulf+\\
\hline
Individual variables&$x, y,...$&Use math mode.\\
\hline
Labels&\lab{1}, \lab{2}, $\alpha, \beta...$&\verb+\lab+ and greek letters.\\
\hline
An example of a formula that's transferred via \entp{tr} into the glue language from other more expressive languages (e.g., from the logic of information content)&$push(e, x, y, \labtwo)$&Use math mode and simply write your text.\\
\hline
The \scshape SDRS\upshape \varsub{K}{l} (i.e., $\mathcal(\lambda)$) includes as a conjunct some rhetorical relation connecting $\alpha$ and $\beta$&$?(\alpha, \beta, \lambda)$&Same as above: math mode!\\
\hline
in the \scshape SDRS\upshape $\langle A, \mathcal{F}\rangle$, where $l \in A$, $\mathcal{F}(\lambda)$ includes $R(\alpha, \beta)$ as one of its conjuncts.&$R(\alpha, \beta, \lambda)$&Once again: math mode!\\
\hline
As in the language of information content&$\wedge, \vee, \rightarrow, \neg, >$&As above, except that $\rightarrow$ is \verb+\rightarrow+ (i.e., without a capital letter).\\
\hline
The information about content that's transferred from $\mathcal{K}$ into the glue logic, where $\mathcal{K}$ is a set of formulae of the \scshape ULF\upshape-logic&$Info(\mathcal{K})$&\verb+Info(\mathcal{K})+ in math mode.\\
\hline
$\sigma$ outscopes $\alpha$ and nothing outscopes $\sigma$&$Top(\sigma, \alpha)$&Simple text in math mode.\\
\hline
There is evidence in the discourse $\sigma$ that $\alpha$ is a subtype of $\beta$; similarly for $\varsub{cause}{D}(\sigma, \alpha, \beta)$&$\varsub{subtype}{D}(\sigma, \alpha, \beta)$&Use \verb+varsub+\\
\hline
A schema, which one can replace with the aktionsart of $\alpha$ and $\beta$, whatever their values&$Aspect(\alpha, \beta)$&Text in math mode.\\
\hline
The formula $\alpha'$ labels is just like that labelled by $\alpha$, save that the former resolves some or all of the underspecifications that's present in the latter.&$\alpha \resolves \alpha'$&This arrow is produced with \verb+\resolves+.\\
\hline
A \scshape DRS \upshape which is the same as $K$, save that some of the underspecified conditions in $K$ are resolved in $K^{+}$&\kstar&Use \verb+\kstar+, which can be an argument of \verb+\varsub+, so you can write, for instance, \varsub{\kstar}{\lab[']{5}} with \verb+\varsub{\kstar}{\lab[']{5}}+.\\
\hline
At the part labelled \varsub{\lambda}{2} in the discourse structure, the content \varsub{K}{\varsub{\lambda}{1}} that \varsub{\lambda}{1} labels (and which in turn is outscoped by \varsub{\lambda}{2}) is settled.&$settled(\varsub{\lambda}{1}, \varsub{\lambda}{2})$&Use text in math mode and \verb+\varsub+.\\
\hline
Type declarations, respectively: $\alpha$ labels an indicative, interrogative, imperative&$\alpha :|, \alpha :?, \alpha :!$&Simple math mode once again.\\
\hline
\multicolumn{3}{|c|}{\textbf{6. Glue Logic: Metalanguage}}\\
\hline
$\Gamma$ monotonically entails $\phi$ (model theory)&$\Gamma \entm \phi$ or $\Gamma \entm[g] \phi$&Use \verb+\entm+ with optional subscript (between brackets).\\
\hline
$\Gamma$ monotonically entails $\phi$ (proof theory)&$\Gamma \entp \phi$ or $\Gamma \entp[g] \phi$&Use \verb+\entp+ with optional subscript (between brackets).\\
\hline
$\Gamma$ nonmonotonically entails $\phi$ (model theory)&$\Gamma \nmentm \phi$ or $\Gamma \nmentm[g] \phi$&Use \verb+\nmentm+ with optional subscript (between brackets).\\
\hline
$\Gamma$ nonmonotonically entails $\phi$ (proof theory)&$\Gamma \nmentp \phi$ or $\Gamma \nmentp[g] \phi$&Use \verb+\nmentp+ with optional subscript (between brackets).\\
\hline
An extension of the theory $T$&\thext&\verb+\thext+, which of course can be argument of \verb+\varsub+ to produce things like \varsub{\thext}{max} as usual.\\
\hline
$Ant(T)\varsub{=}{def}\{C:T\entp C>D\}$&$Ant(T)$&Here is how to write the formula in the left column:

\verb+Ant(T)\varsub{=}{def}\{C:T\entp C>D\}+ The whole in math mode, of course. As you can see, the only thing you have to pay attention to is the braces, which are one of the special characters of \LaTeX. To typeset them, you have to write \verb+\{+ and \verb+\}+.\\ 
\hline
\multicolumn{3}{|c|}{\textbf{7. Discourse Update}}\\
\hline
The transfer relation from (richer) sources of information to the glue language&\entp[tr]&\verb+\entp[tr]+\\
\hline
The set of labels to which $\beta$ is attached&$att-sites(\beta)$&Text in math mode.\\
\hline
The set of available attachment sites in the set of \scshape sdrs\upshape s $\sigma$&$avail-sites(\sigma)$&Text in math mode.\\
\hline
$\{\langle \alpha, l\rangle : \alpha\in avail-sites(\sigma)$ and $\varsub{Succ}{D}(l, \alpha)\}$&$avail-pairs(\sigma)$&Text in math mode. The left column is written just like the definition of $Ant(A)$. Note that `and' mustn't be in math mode, so you have to stop it before and start it again after.\\
\hline
The set of all possible sequences of all possible subsets of $avail-pairs(\sigma)$&$\mathcal{P}(avail-pairs(\sigma))$&$\mathcal{P}$ is \verb+\mathcal{P}+ in math mode, and you must have guessed how the rest was typed...\\
\hline
The \scshape sdrt \upshape update function from an old context and new information to a new context.&\update&Use \verb+\update+. Note that this was designed thanks to the \verb+subscript.sty+ package. I rewrote that part of the code in \verb+sdrt.sty+ so you won't have to (down)load it. By the way, this won't work in math mode. To yield \bestupdate, write \verb+\bestupdate+.\\
\hline
A set of \scshape sdrs\upshape s&$\sigma$&Greek letter sigma.\\
\hline
The set of all \scshape ulf\upshape -formulae $\phi$ such that for all \scshape sdrs\upshape s in $\sigma$, $s\entm[l]\phi$&$Th(\sigma)$&Math mode\\
\hline
The simple update of $\sigma$ with the (assumption about) attachment $?(\alpha, \beta, \lambda)$&$\sigma+?(\alpha, \beta, \lambda)$&Math mode.\\
\hline
The sequence of simple updates of $\sigma$ with $?(\alpha, \beta, \lambda)$ for each $\langle \alpha, l\rangle \in X$&$\varsub{\Sigma}{X}(\sigma, \varsub{\mathcal{K}}{\beta})$&This might seem complicated, but this is not. Here is the code:

\verb+\varsub{\Sigma}{X}+ \verb+(\sigma, \varsub{\mathcal{K}}{\beta})+\\
\hline
Downdating: the set of the biggest bits of $\sigma$ that you can retain while ensuring that the result does not entail $\phi$.&$\sigma\downdate\phi$&Use \verb+\downdate+ to draw \downdate.\\
\hline
$\sigma$ with all $R(\gamma, \alpha, \lambda)$ where $\phi(R)$ retracted, and replaced with $Dis(R)(\gamma, \alpha, \lambda)$&$\sigma \varsub{\topic}{\phi} \alpha$&Use \verb+\varsub{\topic}{\phi}+ to yield \varsub{\topic}{\phi}.\\
\hline
Simple revision (which generalises update)&$\sigma\revision?(\alpha, \beta, \lambda)$&\verb+\revision+ to produce \revision.\\
\hline
\multicolumn{3}{|c|}{\textbf{8. Cognitive Modelling Language}}\\
\hline
\multicolumn{3}{|p{13cm}|}{There is nothing new in that section. Everything is made of \texttt{$\backslash$varsub} or math mode. You already know that $\mathcal{B}$ is \texttt{$\backslash$mathcal\{B\}} in math mode.}\\
\hline
Propositional variables&$\varsub{p}{1}, \varsub{p}{2}, q, q'$,...&\\
\hline
Action terms&\varsub{a}{1}, \varsub{a}{2},...&\\
\hline
Labelled propositional variables&\varsub{p}{\alpha}, \varsub{p}{\lab{}}&Of course, you could write something like \varsub{p}{\lab[']{r}} with \verb+\varsub{p}{\lab[']{r}}+.\\
\hline
Labelled action terms&\varsub{a}{\alpha}, \varsub{a}{\lab{}}&Same comment.\\
\hline
An action term, corresponding to the action of seeing to it that $\phi$ is true&\true{\phi}&\verb+\true{}+ as above.\\
\hline
The speaker who conveyed the content associated with $\alpha$; and the hearer of that content&$S(\alpha), H(\alpha)$&\\
\hline
Agent $A$ believes that; Agent $A$ intends that; $A$ and $B$ mutually believe that&\believes{A}, \intends{A}, \varsub{MB}{A,B}&Use \verb+believes{agent}+ and \verb+\intends{agent}+ without the optional argument. \varsub{MB}{A,B} is simply \verb+\varsub{MB}{A,B}+.\\
\hline	
$A$'s choice for fulfilling the action \true{\psi} is to carry out the action \true{\phi}&$\varsub{choice}{A}(\phi, \psi)$&\verb+\varsub+ and math mode.\\
\hline
The action of $S(\alpha)$ uttering $\alpha$&$Say(\alpha)$&Use math mode.\\
\hline
The action $a$ has been performed&$Done(a)$&Use math mode.\\
\hline
$p$ is an answer to the question labelled by $\alpha$&$Sanswer(\alpha, p)$&Use math mode.\\
\end{mpsupertabular}
\end{center}

\subsection{Additional symbols}
Wandering through \emph{Logics of Conversation}, one can realize that the above notation index is not sufficient to typeset all formulae in \scshape sdrt \upshape. So here are some more useful symbols.

First of all, a `superscript' variant of \verb+\varsub{}{}+ will be interesting. It is simply \verb+\varsup{}{}+. So you can type, for instance, \varsup{\ulf}{sup} with \verb+\varsup{\ulf}{sup}+. Note that \verb+\varsub+ and \verb+\varsup+ can be arguments of each other. So you can type complex stuff like \varsub{\varsup{\ulf}{sup}}{sub} with \verb+\varsub{\varsup{\ulf}{sup}}{sub}+. Note that \verb+\varsup{\varsub{\ulf}{sub}}{sup}+ will yield exactly the same thing. 

Now, here are some more symbols, with the code:

\begin{center}
\begin{tabular}{l l}
$\cup$&\verb+\cup+ in math mode\\
$\circ$ (to define $\Lbracket\varsub{a}{1};\varsub{a}{2}\Rbracket$)&\verb+\circ+ in math mode\\
$\varsub{K}{1} \access \varsub{K}{2}$ (accessibility relation)&\verb+\access+\\
$K := Definition$&Simply \verb+:=+\\	
$\ell$ (in models for \lulf)&\verb+\ell+ in math mode\\
$e \tempprec now$ (temporal precedence)&\verb+\tempprec+\\
$\mathcal{X}$&\verb+\mathcal{X}+ in math mode\\
$\frac{\varsub{R}{f}}{Y}$(in the interpretation of the labelled language)&\verb+frac{above}{below}+ in math mode\\
Negated versions of inference operators:&\\
\Nentm&\verb+\Nentm+\\
\Nentp&\verb+\Nentp+\\
\Nnmentm&\verb+\Nnmentm+\\
\Nnmentp&\verb+\Nnmentp+\\
\union{{X \in \varsub{\mathcal{S}}{\sigma}}} (in SDRT Update)&\verb+\union{limit}+\\
$\alpha \merging \beta$&\verb+\merging+\\
$x \subtype y$&\verb+\subtype+\\
\end{tabular}
\end{center}
Many relations can be negated with the prefix \verb+\not+ (which needs math mode). Thus \verb+\not\extends+	yields $\not\extends$ and \verb+\not\in+ yields $\not\in$. Finally, if you want to draw HPSG-like AVMs for lexical semantics, use Christopher Manning's \verb+avm.sty+ package.

\section{Math mode or not?} 

I am aware of the fact that the many mentions of `math mode' might be very confusing, and that in the end you might not know when to use it. Moreover, maybe you are a new \LaTeX\ user and you ignore what math mode is and why so many \$ are appearing here and there along these pages. So first of all, a definition: math mode is a pair of \$ between which math formulae are nicely formatted. So it is good. However, there is another feature that I can't explain to me: some commands (those in the menu item named `math' in TeXnicCenter) \emph{need} math mode. Greek letters for instance. If you write \verb+\alpha is a nice letter+, it will type `$\alpha$ is a nice letter', but, since \verb+\alpha+ is not surrounded by \$, \LaTeX\ will moan `\verb+Missing $ inserted+', and you'll have two errors. Fortunately, all the macros in this package `control' their `math-modality'\footnote{Thanks to the \texttt{$\backslash$ensuremath} command.}.

The following commands don't need math mode, nor do their argument(s) need it. For instance, \verb+varsub{}{}+ don't need math mode and you don't need to write \verb+\alpha+ between \$ if you want $\alpha$ as one of the arguments. 
\newline
\newline
\noindent\verb+\lab[]{}+, and all its variants: \verb+\labone+, \verb+\klab+, \verb+\flab+, etc.
\begin{verbatim}
\SDRS \PSDRS
\varsub{}{} \varsup{}{}
\intens{} \extens{} \true{}
\necess{}{} \possib{}{}
\append{}{}
\summary
\aflast
\topic
\believes[]{} \intends[]{}
\sarg{}{}
\extends
\ccp[]{}{}{}
\entm[] \entp[] \nmentm[] \nmentp[] \Nentm[] \Nentp[] \Nnmentm[] \Nnmentp[]
\lulf
\trfunc
\outscopes
\ulf
\resolves
\kstar
\thext
\downdate \revision \access \tempprec
\union{}
\merging
\subtype
\end{verbatim}
As we have seen above with (S)DRSs, math mode has side-effects that you might want to avoid. For instance, normal text will be in italics and without space between words. So you have to interrupt math mode when needed (though normally you won't need it much in SDRT), with additional \$. Thus, for instance, \believes[$my sentence$]{A} is typeset with \verb+\believes[$my sentence$]{A}+. 

On the other hand, greek letters, logical connectors, various calligraphic letters (i.e. produced with \verb+\mathcal{}+) and the symbols $\in$ (\verb+\in+), $\cup$ (\verb+\cup+), $\circ$ (\verb+\circ+), $\ell$ (\verb+\ell+) $\frac{above}{below}$ (\verb+\frac{above}{below}+) need math mode. That is, either they're written between \$ or they're arguments of one of the commands above. Thus you'll write \verb+\intens{\alpha}+ and \emph{never} \verb+\intens{$\alpha$}+, or \verb+$\alpha \outscopes \beta$+ (although \verb+\outscopes+ doesn't need it, it won't cause any trouble).

The advantage of automatic math mode is that those commands are launched in the same way in math environment or in text: \verb+\outscopes+ produces \outscopes\ in the last example and in a phrase like `The \outscopes\ relation'. Just note that in text, those commands that don't take arguments will eat subsequent space, so actually you have to write `\verb+the \outscopes\ relation+' when space is needed. Finally, variables without \verb+\varsub+ or \verb+\varsup+, as well as predicates, need math mode (or any of the commands above) to be typed properly, i.e. if you write just \verb+own(x, y)+, you will get `own(x, j)' and not `$own(x, j)$'.

\section{Bugs and enhancements}

\subsection{Problems}
I made the symbols for non-monotonic entailment out of two other symbols: $|$ and $\approx$ for \nmentm\ and $|$ and $\sim$ for \nmentp. I looked for them everywhere, but I wasn't able to find them, that's why I designed them that way (since I don't know how to draw glyphs). They seem to work well, but they might sometimes mess up when \LaTeX\ adjusts the filling of a line, especially in tables, so you might have to work out some adjustment yourself. Note that it sometimes moves from PS to PDF. That's the reason why I did not designed a nicer \entp\ whose branches would be of the same lenghth as those of \entm\ (notice by the way that in every SDRT papers that I read, \entp\ never matched the lenghth of \entm; but \emph{Logics of Conversation}, at least, was explicitely done with \LaTeX). The same holds for \Lbracket\ and \Rbracket. Although they exist in some packages, they didn't look good to me, and anyway I wanted to avoid requiring many packages.

There is another problem, but this one seems to pervade through \TeX\ in general, namely the `double subscript' problem. If you want to print a complex stuff like \entm\ \varsup{\varsub{}{l}}{\varsup{g}{\frac{\ell}{v}}} (which is needed in the interpretation of the labelled language), you can type \verb+\varsup{\varsub{\entm}{l}}{\varsup{g}{\frac{\ell}{v}}}+, but you will have one error (`double subscript'). Moreover, the sub- and the superscripts are not next to the entailment symbol. If you `recreate' \entm\ out of $|$ and = (as I did for \nmentp\ and \nmentm), however, you will have no problem. \verb+\varsup{\varsub{|\hspace{-5pt}=}{l}}{\,\varsup{g}{\frac{\ell}{v}}}+ will print \varsup{\varsub{|\hspace{-5pt}=}{l}}{\varsup{g}{\frac{\ell}{v}}}.

\subsection{Things that could be improved}

A `generalized' math mode could be interesting. I didn't renamed the logical operators nor the greek letters, since you might use many packages, and it could conflict with them. But here is a simple way to use math symbols in both math and text modes. Imagine you want $\alpha$ to work so, for instance. Then create a new command, namely \verb+\newcommand{\Alpha}{\ensuremath{\alpha}}+. Of course, you could name it whatever you want, and `\verb+\Alpha+' is just an example. With that command, you won't have to bother with math mode anymore, it will be automatic when needed. Notice that a command of the form \verb+\newcommand{\Alpha}{$\alpha$}+ would not do: in math mode, it would create an inner pair of \$ that would interrupt it, and thus the greek letter would be in text mode. On the contrary, \verb+\ensuremath{}+ does not launch math mode when already in it. The only problem is that commands of that kind (without argument) eat subsequent space (and thus may require a suffixed $\backslash$). You could use the \verb+xspace.sty+ package, that controls when subsequent space is needed or not. I didn't use it because it yielded bad results with predicates (the right parenthesis was preceded by a blank).

Apart from that, you might have noticed that the arrowheads in trees don't resemble the ones in SDRT. There is no such arrowheads in \verb+xypic+, and I'm not able to draw them. This would be nice however if it could be done, but  it would require another drawing package, and hence rewriting another code for the trees.

Finally, I did not attempt at drawing the diamond-shaped box that one encounters in DRT to handle donkey sentences, because I was not able to draw them properly. Note however that the \verb+xytree.sty+ package, which requires \verb+xypic+ too, has a command \verb+\drsdiabox+ to draw them. There are two problems with \verb+xytree.sty+: first, its \verb+\drsdiabox+ command yields a shivering box. I think the reason is that this package requires \verb+xypic+ \emph{without} the dvips option. Thus, there is no problem with PDFTeX, but all diagonal lines are ugly. Moreover, the diamond box is not stuck to the other boxes, as it should be. I think however that it is easy to fix. The second problem is the following. Compare those two boxes: 

\begin{center}
\drsbox{x, j}{dog(x)\\own(j,x)}
\SDRS{x, j}{dog(x)\\own(j,x)}
\end{center}
The boxes themselves are not at stake. But if you take a look at the shape of the text, you can observe that there are two kinds of italics. The ones in the left box (made with \verb+xytree+) are produced with the \verb+\itshape+ command, while the italics in the right box (made with \verb+sdrt+) are the result of math mode. The fact is that all italics in SDRT papers, either in a box or in text, are produced with math mode, and not with \verb+\itshape+ or \verb+\emph{}+. See the difference:

\begin{tabular}{ll}
\verb+$background$+&$background$\\
\verb+\emph{background}+, \verb+\itshape background+ and \verb+\textit{background}+&\emph{background}\\
\verb+\slshape background+&\slshape background\\
\end{tabular}

\noindent Math mode also prevents parentheses from being in italics, as usual with math formulae. Thus, \verb+xytree+ is not adequate to draw proper boxes.

\end{document}

